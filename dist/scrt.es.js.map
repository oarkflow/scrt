{"version":3,"file":"scrt.es.js","sources":["../src/binary.js","../src/column.js","../src/temporal.js","../src/schema.js","../src/page.js","../src/codec.js","../src/marshal.js","../src/protocol.js","../src/client.js"],"sourcesContent":["export function createBuffer() {\n    return [];\n}\nexport function bufferLength(buf) {\n    return buf.length;\n}\nexport function pushByte(buf, byte) {\n    buf.push(byte & 0xff);\n}\nexport function pushBytes(buf, bytes) {\n    for (let i = 0; i < bytes.length; i += 1) {\n        buf.push(bytes[i] & 0xff);\n    }\n}\nexport function bufferToUint8Array(buf) {\n    return Uint8Array.from(buf);\n}\nexport function concatByteBuffers(buffers) {\n    const total = buffers.reduce((acc, cur) => acc + cur.length, 0);\n    const out = new Uint8Array(total);\n    let offset = 0;\n    for (const buf of buffers) {\n        out.set(Uint8Array.from(buf), offset);\n        offset += buf.length;\n    }\n    return out;\n}\nconst MAX_VARINT_BYTES = 10;\nexport function writeUvarint(buf, value) {\n    let v = BigInt(value);\n    if (v < 0n) {\n        throw new RangeError(\"uvarint cannot be negative\");\n    }\n    while (v >= 0x80n) {\n        pushByte(buf, Number((v & 0x7fn) | 0x80n));\n        v >>= 7n;\n    }\n    pushByte(buf, Number(v));\n}\nexport function writeVarint(buf, value) {\n    let uv = zigZagEncode(BigInt(value));\n    while (uv >= 0x80n) {\n        pushByte(buf, Number((uv & 0x7fn) | 0x80n));\n        uv >>= 7n;\n    }\n    pushByte(buf, Number(uv));\n}\nexport function readUvarint(data, offset) {\n    let x = 0n;\n    let s = 0n;\n    for (let i = 0; i < MAX_VARINT_BYTES; i += 1) {\n        if (offset + i >= data.length) {\n            throw new RangeError(\"uvarint exceeds buffer\");\n        }\n        const b = BigInt(data[offset + i]);\n        if ((b & 0x80n) === 0n) {\n            x |= (b & 0x7fn) << s;\n            return { value: x, bytesRead: i + 1 };\n        }\n        x |= (b & 0x7fn) << s;\n        s += 7n;\n    }\n    throw new RangeError(\"uvarint too large\");\n}\nexport function readVarint(data, offset) {\n    const { value, bytesRead } = readUvarint(data, offset);\n    return { value: zigZagDecode(value), bytesRead };\n}\nfunction zigZagEncode(value) {\n    return (value << 1n) ^ (value >> 63n);\n}\nfunction zigZagDecode(value) {\n    return (value >> 1n) ^ -(value & 1n);\n}\nexport class BinaryWriter {\n    chunks = [];\n    current = createBuffer();\n    writeByte(byte) {\n        pushByte(this.current, byte);\n    }\n    writeBytes(bytes) {\n        pushBytes(this.current, bytes);\n    }\n    writeBuffer(buffer) {\n        this.flushCurrent();\n        this.chunks.push(buffer.slice());\n        this.current = createBuffer();\n    }\n    writeUint8Array(arr) {\n        this.flushCurrent();\n        this.chunks.push(Array.from(arr));\n        this.current = createBuffer();\n    }\n    writeUvarint(value) {\n        writeUvarint(this.current, value);\n    }\n    toUint8Array() {\n        this.flushCurrent();\n        return concatByteBuffers(this.chunks);\n    }\n    reset() {\n        this.chunks.length = 0;\n        this.current = createBuffer();\n    }\n    flushCurrent() {\n        if (this.current.length > 0) {\n            this.chunks.push(this.current);\n            this.current = createBuffer();\n        }\n    }\n}\nexport class BinaryReader {\n    data;\n    offset;\n    constructor(data, offset = 0) {\n        this.data = data;\n        this.offset = offset;\n    }\n    ensure(size) {\n        if (this.offset + size > this.data.length) {\n            throw new RangeError(\"buffer underrun\");\n        }\n    }\n    readByte() {\n        this.ensure(1);\n        return this.data[this.offset++];\n    }\n    readBytes(length) {\n        this.ensure(length);\n        const slice = this.data.subarray(this.offset, this.offset + length);\n        this.offset += length;\n        return slice;\n    }\n    readUvarint() {\n        const { value, bytesRead } = readUvarint(this.data, this.offset);\n        this.offset += bytesRead;\n        return value;\n    }\n    readVarint() {\n        const { value, bytesRead } = readVarint(this.data, this.offset);\n        this.offset += bytesRead;\n        return value;\n    }\n    remaining() {\n        return this.data.length - this.offset;\n    }\n}\nexport function toSafeNumber(value, label) {\n    const v = Number(value);\n    if (!Number.isFinite(v) || v > Number.MAX_SAFE_INTEGER) {\n        throw new RangeError(`${label} exceeds safe number range`);\n    }\n    return v;\n}\nexport function encodeUint64LE(value) {\n    const v = BigInt(value);\n    const out = new Uint8Array(8);\n    let temp = v;\n    for (let i = 0; i < 8; i += 1) {\n        out[i] = Number(temp & 0xffn);\n        temp >>= 8n;\n    }\n    return out;\n}\n","import { pushByte, pushBytes, writeUvarint, writeVarint } from \"./binary\";\nconst encoder = new TextEncoder();\nexport class Uint64Column {\n    values = [];\n    append(value) {\n        this.values.push(BigInt(value));\n    }\n    encode(dst) {\n        const count = this.values.length;\n        const mode = count >= 2 && isMonotonic(this.values) ? 1n : 0n;\n        const header = (BigInt(count) << 1n) | mode;\n        writeUvarint(dst, header);\n        if (count === 0) {\n            return;\n        }\n        if (mode === 0n) {\n            for (const value of this.values) {\n                writeUvarint(dst, value);\n            }\n            return;\n        }\n        writeUvarint(dst, this.values[0]);\n        let prev = this.values[0];\n        for (let i = 1; i < count; i += 1) {\n            const delta = this.values[i] - prev;\n            writeUvarint(dst, delta);\n            prev = this.values[i];\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class Int64Column {\n    values = [];\n    append(value) {\n        this.values.push(BigInt(value));\n    }\n    encode(dst) {\n        const count = this.values.length;\n        const mode = count > 1 ? 1n : 0n;\n        const header = (BigInt(count) << 1n) | mode;\n        writeUvarint(dst, header);\n        if (count === 0) {\n            return;\n        }\n        if (mode === 0n) {\n            for (const value of this.values) {\n                writeVarint(dst, value);\n            }\n            return;\n        }\n        writeVarint(dst, this.values[0]);\n        let prev = this.values[0];\n        for (let i = 1; i < count; i += 1) {\n            const delta = this.values[i] - prev;\n            writeVarint(dst, delta);\n            prev = this.values[i];\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class Float64Column {\n    values = [];\n    append(value) {\n        this.values.push(value);\n    }\n    encode(dst) {\n        writeUvarint(dst, this.values.length);\n        for (const value of this.values) {\n            writeFloat64(dst, value);\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class BoolColumn {\n    values = [];\n    append(value) {\n        this.values.push(value ? 1 : 0);\n    }\n    encode(dst) {\n        writeUvarint(dst, this.values.length);\n        for (const value of this.values) {\n            pushByte(dst, value);\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class StringColumn {\n    dict = new Map();\n    entries = [];\n    indexes = [];\n    append(value) {\n        if (!this.dict.has(value)) {\n            const bytes = encoder.encode(value);\n            this.dict.set(value, this.entries.length);\n            this.entries.push(bytes);\n        }\n        this.indexes.push(this.dict.get(value));\n    }\n    encode(dst) {\n        writeUvarint(dst, this.entries.length);\n        for (const entry of this.entries) {\n            writeUvarint(dst, entry.length);\n            pushBytes(dst, entry);\n        }\n        writeUvarint(dst, this.indexes.length);\n        for (const idx of this.indexes) {\n            writeUvarint(dst, BigInt(idx));\n        }\n    }\n    reset() {\n        this.dict.clear();\n        this.entries.length = 0;\n        this.indexes.length = 0;\n    }\n}\nexport class BytesColumn {\n    values = [];\n    append(value) {\n        const copy = new Uint8Array(value.length);\n        copy.set(value);\n        this.values.push(copy);\n    }\n    encode(dst) {\n        writeUvarint(dst, this.values.length);\n        for (const value of this.values) {\n            writeUvarint(dst, value.length);\n            pushBytes(dst, value);\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nfunction isMonotonic(values) {\n    for (let i = 1; i < values.length; i += 1) {\n        if (values[i] < values[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction writeFloat64(dst, value) {\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n    view.setFloat64(0, value, true);\n    for (let i = 0; i < 8; i += 1) {\n        pushByte(dst, view.getUint8(i));\n    }\n}\n","const ISO_DATE = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\nconst ISO_DATE_TIME = /^(\\d{4})-(\\d{2})-(\\d{2})[ T](\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{1,9}))?)?$/;\nconst NUMERIC = /^[-+]?\\d+(?:\\.\\d+)?$/;\nconst DURATION_TOKEN = /(\\d+(?:\\.\\d+)?)(ns|us|µs|ms|s|m|h|d)/gi;\nconst NANOS = {\n    ns: 1n,\n    us: 1000n,\n    \"µs\": 1000n,\n    ms: 1000000n,\n    s: 1000000000n,\n    m: 60n * 1000000000n,\n    h: 60n * 60n * 1000000000n,\n    d: 24n * 60n * 60n * 1000000000n,\n};\nexport function parseDate(raw) {\n    const trimmed = raw.trim();\n    const iso = ISO_DATE.exec(trimmed);\n    if (!iso) {\n        const parsed = new Date(trimmed);\n        if (Number.isNaN(parsed.getTime())) {\n            throw new Error(`temporal: invalid date ${raw}`);\n        }\n        return utcDate(parsed.getUTCFullYear(), parsed.getUTCMonth(), parsed.getUTCDate());\n    }\n    const [, year, month, day] = iso;\n    return utcDate(Number(year), Number(month) - 1, Number(day));\n}\nexport function parseDateTime(raw) {\n    const trimmed = raw.trim();\n    const match = ISO_DATE_TIME.exec(trimmed);\n    if (!match) {\n        const parsed = new Date(trimmed);\n        if (Number.isNaN(parsed.getTime())) {\n            throw new Error(`temporal: invalid datetime ${raw}`);\n        }\n        return new Date(parsed.toISOString());\n    }\n    const [, y, m, d, hh, mm, ss = \"0\", frac = \"0\"] = match;\n    const nanos = normalizeFraction(frac);\n    const date = Date.UTC(Number(y), Number(m) - 1, Number(d), Number(hh), Number(mm), Number(ss));\n    return new Date(date + Number(nanos / 1000000n));\n}\nexport function parseTimestamp(raw) {\n    const trimmed = raw.trim();\n    if (NUMERIC.test(trimmed)) {\n        return numericTimestamp(trimmed);\n    }\n    const parsed = new Date(trimmed);\n    if (Number.isNaN(parsed.getTime())) {\n        return parseDateTime(trimmed);\n    }\n    return new Date(parsed.toISOString());\n}\nexport function parseTimestampTZ(raw) {\n    const trimmed = raw.trim();\n    if (NUMERIC.test(trimmed)) {\n        return numericTimestamp(trimmed);\n    }\n    const parsed = new Date(trimmed);\n    if (Number.isNaN(parsed.getTime())) {\n        throw new Error(`temporal: invalid timestamptz ${raw}`);\n    }\n    return parsed;\n}\nexport function parseDuration(raw) {\n    const trimmed = raw.trim();\n    if (!trimmed) {\n        throw new Error(\"temporal: empty duration\");\n    }\n    let total = 0n;\n    let matched = false;\n    for (const token of trimmed.matchAll(DURATION_TOKEN)) {\n        matched = true;\n        const [, value, unitRaw] = token;\n        const unit = unitRaw.toLowerCase();\n        const scale = NANOS[unit];\n        if (!scale) {\n            throw new Error(`temporal: unsupported duration unit ${unitRaw}`);\n        }\n        const [whole, frac = \"0\"] = value.split(\".\");\n        let nanos = BigInt(whole) * scale;\n        if (frac) {\n            const fracScale = scale / powerOfTen(frac.length);\n            nanos += BigInt(frac) * fracScale;\n        }\n        total += nanos;\n    }\n    if (!matched) {\n        throw new Error(`temporal: malformed duration ${raw}`);\n    }\n    return total;\n}\nexport function encodeInstant(value) {\n    if (value instanceof Date) {\n        return BigInt(value.getTime()) * 1000000n;\n    }\n    if (typeof value === \"number\") {\n        return BigInt(Math.trunc(value)) * 1000000n;\n    }\n    return value;\n}\nexport function encodeDate(value) {\n    if (value instanceof Date) {\n        const midnight = utcDate(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate());\n        return BigInt(midnight.getTime()) * 1000000n;\n    }\n    const parsed = parseDate(value);\n    return BigInt(parsed.getTime()) * 1000000n;\n}\nexport function formatTimestampTZ(value) {\n    return value.toISOString();\n}\nexport function canonicalTimestampTZ(raw) {\n    if (!raw.trim()) {\n        return \"\";\n    }\n    const parsed = parseTimestampTZ(raw);\n    return formatTimestampTZ(parsed);\n}\nexport function decodeInstant(value) {\n    const ns = BigInt(value);\n    if (ns === 0n) {\n        return new Date(0);\n    }\n    const ms = Number(ns / 1000000n);\n    return new Date(ms);\n}\nexport function decodeDate(value) {\n    return decodeInstant(value);\n}\nexport function formatDate(value) {\n    if (!Number.isFinite(value.getTime())) {\n        return \"\";\n    }\n    return value.toISOString().slice(0, 10);\n}\nexport function formatInstant(value) {\n    if (!Number.isFinite(value.getTime())) {\n        return \"\";\n    }\n    return value.toISOString();\n}\nexport function numericTimestamp(raw) {\n    if (raw.includes(\".\")) {\n        const [whole, frac] = raw.split(\".\");\n        const sec = BigInt(whole);\n        const fracDigits = BigInt(powerOfTen(frac.length));\n        const nanos = (BigInt(frac) * 1000000000n) / fracDigits;\n        return new Date(Number(sec * 1000n + nanos / 1000000n));\n    }\n    const value = BigInt(raw);\n    const nanos = inferEpochNanoseconds(value);\n    return new Date(Number(nanos / 1000000n));\n}\nexport function inferEpochNanoseconds(value) {\n    const abs = value < 0n ? -value : value;\n    if (abs < 100000000000n) {\n        return value * 1000000000n;\n    }\n    if (abs < 100000000000000n) {\n        return value * 1000000n;\n    }\n    if (abs < 100000000000000000n) {\n        return value * 1000n;\n    }\n    return value;\n}\nconst DURATION_UNITS = [\n    { nanos: 24n * 60n * 60n * 1000000000n, suffix: \"d\" },\n    { nanos: 60n * 60n * 1000000000n, suffix: \"h\" },\n    { nanos: 60n * 1000000000n, suffix: \"m\" },\n    { nanos: 1000000000n, suffix: \"s\" },\n    { nanos: 1000000n, suffix: \"ms\" },\n    { nanos: 1000n, suffix: \"µs\" },\n    { nanos: 1n, suffix: \"ns\" },\n];\nexport function formatDuration(nanos) {\n    if (nanos === 0n) {\n        return \"0s\";\n    }\n    const negative = nanos < 0n;\n    let remaining = negative ? -nanos : nanos;\n    const chunks = [];\n    for (const unit of DURATION_UNITS) {\n        if (remaining < unit.nanos) {\n            continue;\n        }\n        const value = remaining / unit.nanos;\n        remaining -= value * unit.nanos;\n        chunks.push(`${value}${unit.suffix}`);\n        if (remaining === 0n) {\n            break;\n        }\n    }\n    if (remaining > 0n) {\n        chunks.push(`${remaining}ns`);\n    }\n    return `${negative ? \"-\" : \"\"}${chunks.join(\"\")}`;\n}\nfunction utcDate(year, month, day) {\n    return new Date(Date.UTC(year, month, day, 0, 0, 0, 0));\n}\nfunction normalizeFraction(input) {\n    const digits = input.padEnd(9, \"0\").slice(0, 9);\n    return BigInt(digits);\n}\nfunction powerOfTen(exp) {\n    let result = 1n;\n    for (let i = 0; i < exp; i += 1) {\n        result *= 10n;\n    }\n    return result;\n}\n","import { encodeDate, encodeInstant, formatTimestampTZ, parseDate, parseDateTime, parseDuration, parseTimestamp, parseTimestampTZ } from \"./temporal\";\nconst FNV_OFFSET = 0xcbf29ce484222325n;\nconst FNV_PRIME = 0x100000001b3n;\nexport var FieldKind;\n(function (FieldKind) {\n    FieldKind[FieldKind[\"Invalid\"] = 0] = \"Invalid\";\n    FieldKind[FieldKind[\"Uint64\"] = 1] = \"Uint64\";\n    FieldKind[FieldKind[\"String\"] = 2] = \"String\";\n    FieldKind[FieldKind[\"Ref\"] = 3] = \"Ref\";\n    FieldKind[FieldKind[\"Bool\"] = 4] = \"Bool\";\n    FieldKind[FieldKind[\"Int64\"] = 5] = \"Int64\";\n    FieldKind[FieldKind[\"Float64\"] = 6] = \"Float64\";\n    FieldKind[FieldKind[\"Bytes\"] = 7] = \"Bytes\";\n    FieldKind[FieldKind[\"Date\"] = 8] = \"Date\";\n    FieldKind[FieldKind[\"DateTime\"] = 9] = \"DateTime\";\n    FieldKind[FieldKind[\"Timestamp\"] = 10] = \"Timestamp\";\n    FieldKind[FieldKind[\"TimestampTZ\"] = 11] = \"TimestampTZ\";\n    FieldKind[FieldKind[\"Duration\"] = 12] = \"Duration\";\n})(FieldKind || (FieldKind = {}));\nexport class DefaultValue {\n    kind;\n    boolValue;\n    intValue;\n    uintValue;\n    floatValue;\n    stringValue;\n    bytesValue;\n    constructor(kind, boolValue, intValue, uintValue, floatValue, stringValue, bytesValue) {\n        this.kind = kind;\n        this.boolValue = boolValue;\n        this.intValue = intValue;\n        this.uintValue = uintValue;\n        this.floatValue = floatValue;\n        this.stringValue = stringValue;\n        this.bytesValue = bytesValue;\n    }\n    hashKey() {\n        switch (this.kind) {\n            case FieldKind.Bool:\n                return `bool:${this.boolValue ? 1 : 0}`;\n            case FieldKind.Int64:\n                return `int:${this.intValue ?? 0n}`;\n            case FieldKind.Uint64:\n            case FieldKind.Ref:\n                return `uint:${this.uintValue ?? 0n}`;\n            case FieldKind.Float64:\n                return `float:${this.floatValue ?? 0}`;\n            case FieldKind.String:\n                return `string:${this.stringValue ?? \"\"}`;\n            case FieldKind.Bytes:\n                return `bytes:${bytesToBase64(this.bytesValue ?? new Uint8Array())}`;\n            case FieldKind.Date:\n            case FieldKind.DateTime:\n            case FieldKind.Timestamp:\n            case FieldKind.Duration:\n                return `int:${this.intValue ?? 0n}`;\n            case FieldKind.TimestampTZ:\n                return `timestamptz:${this.stringValue ?? \"\"}`;\n            default:\n                return \"\";\n        }\n    }\n}\nexport class Field {\n    name;\n    kind;\n    rawType;\n    targetSchema;\n    targetField;\n    autoIncrement;\n    attributes;\n    defaultValue;\n    resolvedKind = FieldKind.Invalid;\n    pendingDefault = \"\";\n    constructor(name, kind, rawType, targetSchema = \"\", targetField = \"\", autoIncrement = false, attributes = [], defaultValue) {\n        this.name = name;\n        this.kind = kind;\n        this.rawType = rawType;\n        this.targetSchema = targetSchema;\n        this.targetField = targetField;\n        this.autoIncrement = autoIncrement;\n        this.attributes = attributes;\n        this.defaultValue = defaultValue;\n    }\n    valueKind() {\n        if (this.kind === FieldKind.Ref) {\n            return this.resolvedKind === FieldKind.Invalid ? FieldKind.Uint64 : this.resolvedKind;\n        }\n        return this.resolvedKind === FieldKind.Invalid ? this.kind : this.resolvedKind;\n    }\n    isReference() {\n        return this.kind === FieldKind.Ref && !!this.targetSchema && !!this.targetField;\n    }\n}\nexport class Schema {\n    name;\n    fields;\n    fingerprintCache;\n    fieldIndex;\n    constructor(name, fields) {\n        this.name = name;\n        this.fields = fields;\n    }\n    fingerprint() {\n        if (this.fingerprintCache !== undefined) {\n            return this.fingerprintCache;\n        }\n        let hash = FNV_OFFSET;\n        const write = (str) => {\n            for (let i = 0; i < str.length; i += 1) {\n                hash ^= BigInt(str.charCodeAt(i));\n                hash = BigInt.asUintN(64, hash * FNV_PRIME);\n            }\n        };\n        write(this.name);\n        for (const field of this.fields) {\n            write(\"|\");\n            write(field.name);\n            write(\":\");\n            write(field.rawType);\n            if (field.targetSchema) {\n                write(\"->\");\n                write(`${field.targetSchema}.${field.targetField}`);\n            }\n            if (field.autoIncrement) {\n                write(\"+auto\");\n            }\n            if (field.attributes.length) {\n                const attrs = [...field.attributes].sort();\n                for (const attr of attrs) {\n                    write(`@${attr}`);\n                }\n            }\n            if (field.defaultValue) {\n                write(\"=def:\");\n                write(field.defaultValue.hashKey());\n            }\n        }\n        this.fingerprintCache = BigInt.asUintN(64, hash);\n        return this.fingerprintCache;\n    }\n    fieldIndexByName(name) {\n        if (!this.fieldIndex) {\n            this.fieldIndex = new Map();\n            this.fields.forEach((field, idx) => this.fieldIndex.set(field.name, idx));\n        }\n        const idx = this.fieldIndex.get(name);\n        if (idx === undefined) {\n            throw new Error(`scrt: field ${name} not found in schema ${this.name}`);\n        }\n        return idx;\n    }\n    tryFieldIndex(name) {\n        if (!this.fieldIndex) {\n            this.fieldIndex = new Map();\n            this.fields.forEach((field, idx) => this.fieldIndex.set(field.name, idx));\n        }\n        return this.fieldIndex.get(name);\n    }\n}\nexport class Document {\n    schemas;\n    data;\n    source;\n    constructor(schemas, data, source) {\n        this.schemas = schemas;\n        this.data = data;\n        this.source = source;\n    }\n    schema(name) {\n        return this.schemas.get(name);\n    }\n    records(name) {\n        return this.data.get(name);\n    }\n    finalize() {\n        for (const schema of this.schemas.values()) {\n            resolveSchemaKinds(this, schema);\n        }\n    }\n}\nexport function parseSchema(text) {\n    const lines = text.split(/\\r?\\n/).map((line) => line.trim());\n    const schemas = new Map();\n    const data = new Map();\n    let current;\n    let awaitingName = false;\n    let currentData = \"\";\n    const finishCurrent = () => {\n        if (!current) {\n            return;\n        }\n        if (schemas.has(current.name)) {\n            throw new Error(`scrt: duplicate schema ${current.name}`);\n        }\n        schemas.set(current.name, current);\n        current = undefined;\n    };\n    const startSchema = (name) => {\n        finishCurrent();\n        if (!name) {\n            throw new Error(\"scrt: schema name cannot be empty\");\n        }\n        current = new Schema(name, []);\n    };\n    for (const line of lines) {\n        if (!line) {\n            continue;\n        }\n        if (awaitingName) {\n            startSchema(line);\n            awaitingName = false;\n            continue;\n        }\n        if (line.startsWith(\"@schema\")) {\n            currentData = \"\";\n            let rest = line.slice(\"@schema\".length).trim();\n            if (rest.startsWith(\":\")) {\n                rest = rest.slice(1).trim();\n            }\n            if (!rest) {\n                awaitingName = true;\n                continue;\n            }\n            startSchema(rest);\n            continue;\n        }\n        if (line.startsWith(\"@field\")) {\n            currentData = \"\";\n            if (!current) {\n                throw new Error(\"scrt: @field outside schema block\");\n            }\n            const field = parseField(line.slice(\"@field\".length).trim());\n            current.fields.push(field);\n            continue;\n        }\n        if (line.startsWith(\"@\")) {\n            awaitingName = false;\n            finishCurrent();\n            if (line.includes(\"=\") && currentData) {\n                const sch = schemas.get(currentData);\n                if (sch) {\n                    const row = parseDataRow(line, sch);\n                    pushDataRow(data, currentData, row);\n                }\n                continue;\n            }\n            currentData = line.slice(1).trim();\n            continue;\n        }\n        if (currentData) {\n            const sch = schemas.get(currentData);\n            if (!sch) {\n                continue;\n            }\n            const row = parseDataRow(line, sch);\n            pushDataRow(data, currentData, row);\n            continue;\n        }\n    }\n    finishCurrent();\n    const doc = new Document(schemas, data);\n    doc.finalize();\n    return doc;\n}\nfunction pushDataRow(store, schemaName, row) {\n    if (!store.has(schemaName)) {\n        store.set(schemaName, []);\n    }\n    store.get(schemaName).push(row);\n}\nfunction parseField(body) {\n    const [name, typ, attrChunk] = splitFieldParts(body);\n    const { kind, targetSchema, targetField } = interpretFieldType(typ);\n    const field = new Field(name, kind, typ, targetSchema, targetField);\n    if (attrChunk) {\n        const attrs = splitFieldAttributes(attrChunk);\n        for (const attr of attrs) {\n            const lower = attr.toLowerCase();\n            switch (true) {\n                case lower === \"auto_increment\" || lower === \"autoincrement\" || lower === \"serial\":\n                    field.autoIncrement = true;\n                    break;\n                case lower.startsWith(\"default=\"):\n                case lower.startsWith(\"default:\"):\n                    assignFieldDefault(field, extractDefaultLiteral(attr));\n                    break;\n                default:\n                    break;\n            }\n            field.attributes.push(lower);\n        }\n    }\n    return field;\n}\nfunction splitFieldParts(body) {\n    const trimmed = body.trim();\n    const firstSep = trimmed.search(/[ \\t]/);\n    if (firstSep === -1) {\n        throw new Error(`scrt: invalid @field declaration ${body}`);\n    }\n    const name = trimmed.slice(0, firstSep).trim();\n    const rest = trimmed.slice(firstSep + 1).trim();\n    const secondSep = rest.search(/[ \\t]/);\n    if (secondSep === -1) {\n        return [name, rest, \"\"];\n    }\n    return [name, rest.slice(0, secondSep).trim(), rest.slice(secondSep + 1).trim()];\n}\nfunction interpretFieldType(raw) {\n    const typ = raw.toLowerCase();\n    switch (true) {\n        case typ === \"uint64\":\n            return { kind: FieldKind.Uint64, targetSchema: \"\", targetField: \"\" };\n        case typ === \"string\":\n            return { kind: FieldKind.String, targetSchema: \"\", targetField: \"\" };\n        case typ === \"bool\":\n            return { kind: FieldKind.Bool, targetSchema: \"\", targetField: \"\" };\n        case typ === \"int64\":\n            return { kind: FieldKind.Int64, targetSchema: \"\", targetField: \"\" };\n        case typ === \"float64\":\n            return { kind: FieldKind.Float64, targetSchema: \"\", targetField: \"\" };\n        case typ === \"bytes\":\n            return { kind: FieldKind.Bytes, targetSchema: \"\", targetField: \"\" };\n        case typ === \"date\":\n            return { kind: FieldKind.Date, targetSchema: \"\", targetField: \"\" };\n        case typ === \"datetime\":\n            return { kind: FieldKind.DateTime, targetSchema: \"\", targetField: \"\" };\n        case typ === \"timestamp\":\n            return { kind: FieldKind.Timestamp, targetSchema: \"\", targetField: \"\" };\n        case typ === \"timestamptz\":\n            return { kind: FieldKind.TimestampTZ, targetSchema: \"\", targetField: \"\" };\n        case typ === \"duration\":\n            return { kind: FieldKind.Duration, targetSchema: \"\", targetField: \"\" };\n        case typ.startsWith(\"ref:\"):\n            const [, schemaName, fieldName] = raw.split(\":\");\n            return { kind: FieldKind.Ref, targetSchema: schemaName ?? \"\", targetField: fieldName ?? \"\" };\n        default:\n            throw new Error(`scrt: unsupported field type ${raw}`);\n    }\n}\nfunction splitFieldAttributes(attrChunk) {\n    const attrs = [];\n    let current = \"\";\n    let quote = null;\n    for (const ch of attrChunk) {\n        if ((ch === '\"' || ch === \"'\" || ch === \"`\") && quote === null) {\n            quote = ch;\n            current += ch;\n        }\n        else if (quote && ch === quote) {\n            quote = null;\n            current += ch;\n        }\n        else if (!quote && ch === ',') {\n            if (current.trim()) {\n                attrs.push(current.trim());\n            }\n            current = \"\";\n        }\n        else {\n            current += ch;\n        }\n    }\n    if (current.trim()) {\n        attrs.push(current.trim());\n    }\n    return attrs;\n}\nfunction assignFieldDefault(field, literalRaw) {\n    const literal = literalRaw.trim();\n    if (!literal) {\n        return;\n    }\n    if (field.kind === FieldKind.Ref) {\n        field.pendingDefault = literal;\n        return;\n    }\n    field.defaultValue = parseDefaultLiteral(field.kind, literal);\n}\nfunction extractDefaultLiteral(attr) {\n    const sepIdx = attr.indexOf(\"=\") >= 0 ? attr.indexOf(\"=\") : attr.indexOf(\":\");\n    if (sepIdx === -1) {\n        return attr;\n    }\n    return attr.slice(sepIdx + 1);\n}\nfunction parseDefaultLiteral(kind, literal) {\n    switch (kind) {\n        case FieldKind.Bool:\n            return new DefaultValue(kind, literal.toLowerCase() === \"true\" || literal === \"1\");\n        case FieldKind.Int64:\n            return new DefaultValue(kind, undefined, BigInt(literal));\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            return new DefaultValue(kind, undefined, undefined, BigInt(literal));\n        case FieldKind.Float64:\n            return new DefaultValue(kind, undefined, undefined, undefined, Number(literal));\n        case FieldKind.String:\n            return new DefaultValue(kind, undefined, undefined, undefined, undefined, parseStringLiteral(literal));\n        case FieldKind.Bytes:\n            return new DefaultValue(kind, undefined, undefined, undefined, undefined, undefined, parseBytesLiteral(literal));\n        case FieldKind.Date:\n            return new DefaultValue(kind, undefined, encodeDate(parseDate(stripQuotes(literal))));\n        case FieldKind.DateTime:\n            return new DefaultValue(kind, undefined, encodeInstant(parseDateTime(stripQuotes(literal))));\n        case FieldKind.Timestamp:\n            return new DefaultValue(kind, undefined, encodeInstant(parseTimestamp(stripQuotes(literal))));\n        case FieldKind.TimestampTZ: {\n            const ts = parseTimestampTZ(stripQuotes(literal));\n            return new DefaultValue(kind, undefined, undefined, undefined, undefined, formatTimestampTZ(ts));\n        }\n        case FieldKind.Duration:\n            return new DefaultValue(kind, undefined, parseDuration(stripQuotes(literal)));\n        default:\n            throw new Error(`scrt: defaults not supported for kind ${kind}`);\n    }\n}\nfunction parseStringLiteral(raw) {\n    const trimmed = raw.trim();\n    if (!trimmed) {\n        return \"\";\n    }\n    if (trimmed.startsWith(\"\\\"\") || trimmed.startsWith(\"'\") || trimmed.startsWith(\"`\")) {\n        return trimmed.slice(1, -1);\n    }\n    return trimmed;\n}\nfunction stripQuotes(raw) {\n    const trimmed = raw.trim();\n    if (!trimmed) {\n        return \"\";\n    }\n    if ((trimmed.startsWith(\"\\\"\") && trimmed.endsWith(\"\\\"\")) || (trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\")) || (trimmed.startsWith(\"`\") && trimmed.endsWith(\"`\"))) {\n        return trimmed.slice(1, -1);\n    }\n    return trimmed;\n}\nfunction parseBytesLiteral(raw) {\n    const trimmed = raw.trim();\n    if (trimmed.startsWith(\"0x\") || trimmed.startsWith(\"0X\")) {\n        const hex = trimmed.slice(2);\n        if (hex.length % 2 !== 0) {\n            throw new Error(`scrt: invalid hex literal ${raw}`);\n        }\n        const bytes = new Uint8Array(hex.length / 2);\n        for (let i = 0; i < hex.length; i += 2) {\n            bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n        }\n        return bytes;\n    }\n    return new TextEncoder().encode(stripQuotes(trimmed));\n}\nfunction parseDataRow(line, schema) {\n    const row = {};\n    const tokens = line.split(',');\n    let fieldIdx = 0;\n    let remaining = countValueTokens(tokens);\n    const skipAuto = () => {\n        while (fieldIdx < schema.fields.length && schema.fields[fieldIdx].autoIncrement) {\n            const nonAuto = countNonAuto(schema.fields, fieldIdx);\n            if (remaining > nonAuto) {\n                return;\n            }\n            fieldIdx += 1;\n        }\n    };\n    for (const token of tokens) {\n        const trimmed = token.trim();\n        if (!trimmed) {\n            fieldIdx += 1;\n            continue;\n        }\n        if (trimmed.startsWith(\"@\")) {\n            const { index, value } = applyExplicitAssignment(schema, trimmed.slice(1));\n            if (index >= 0) {\n                row[schema.fields[index].name] = value;\n                fieldIdx = Math.max(fieldIdx, index + 1);\n            }\n            continue;\n        }\n        skipAuto();\n        if (fieldIdx >= schema.fields.length) {\n            throw new Error(\"scrt: too many values in row\");\n        }\n        const field = schema.fields[fieldIdx];\n        row[field.name] = parseValue(trimmed, field);\n        fieldIdx += 1;\n        remaining -= 1;\n    }\n    return row;\n}\nfunction countValueTokens(tokens) {\n    return tokens.reduce((acc, token) => {\n        const trimmed = token.trim();\n        if (!trimmed || trimmed.startsWith(\"@\")) {\n            return acc;\n        }\n        return acc + 1;\n    }, 0);\n}\nfunction countNonAuto(fields, start) {\n    let count = 0;\n    for (let i = start; i < fields.length; i += 1) {\n        if (!fields[i].autoIncrement) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction applyExplicitAssignment(schema, expr) {\n    const [fieldToken, rawValue] = expr.split(\"=\", 2);\n    if (!rawValue) {\n        throw new Error(`scrt: invalid assignment ${expr}`);\n    }\n    const normalized = normalizeAssignmentTarget(fieldToken);\n    const idx = schema.tryFieldIndex(normalized);\n    if (idx === undefined) {\n        throw new Error(`scrt: field ${normalized} not found`);\n    }\n    const field = schema.fields[idx];\n    return { index: idx, value: parseValue(rawValue.trim(), field) };\n}\nfunction normalizeAssignmentTarget(token) {\n    const trimmed = token.trim();\n    const parts = trimmed.split(\":\");\n    if (parts.length >= 2) {\n        return parts[1];\n    }\n    return parts[0];\n}\nfunction parseValue(raw, field) {\n    const kind = field.valueKind();\n    const trimmed = raw.trim();\n    switch (kind) {\n        case FieldKind.Uint64:\n            return BigInt(trimmed);\n        case FieldKind.Int64:\n            return BigInt(trimmed);\n        case FieldKind.Float64:\n            return Number(trimmed);\n        case FieldKind.Bool:\n            return trimmed.toLowerCase() === \"true\" || trimmed === \"1\";\n        case FieldKind.String:\n            return stripQuotes(trimmed);\n        case FieldKind.Bytes:\n            return parseBytesLiteral(trimmed);\n        case FieldKind.Date:\n            return parseDate(stripQuotes(trimmed));\n        case FieldKind.DateTime:\n            return parseDateTime(stripQuotes(trimmed));\n        case FieldKind.Timestamp:\n            return parseTimestamp(stripQuotes(trimmed));\n        case FieldKind.TimestampTZ:\n            return parseTimestampTZ(stripQuotes(trimmed));\n        case FieldKind.Duration:\n            return parseDuration(stripQuotes(trimmed));\n        default:\n            return trimmed;\n    }\n}\nfunction resolveSchemaKinds(doc, schema) {\n    schema.fields.forEach((field, idx) => resolveFieldKind(doc, schema, idx, new Set()));\n}\nfunction resolveFieldKind(doc, schema, idx, stack) {\n    const field = schema.fields[idx];\n    if (field.resolvedKind !== FieldKind.Invalid) {\n        return field.resolvedKind;\n    }\n    if (field.kind !== FieldKind.Ref) {\n        field.resolvedKind = field.kind;\n        if (field.pendingDefault && !field.defaultValue) {\n            field.defaultValue = parseDefaultLiteral(field.resolvedKind, field.pendingDefault);\n            field.pendingDefault = \"\";\n        }\n        return field.resolvedKind;\n    }\n    const key = `${schema.name}.${field.name}`;\n    if (stack.has(key)) {\n        throw new Error(`scrt: circular reference detected for ${key}`);\n    }\n    stack.add(key);\n    const targetSchema = doc.schemas.get(field.targetSchema);\n    if (!targetSchema) {\n        throw new Error(`scrt: schema ${schema.name} references unknown schema ${field.targetSchema}`);\n    }\n    const targetIdx = targetSchema.tryFieldIndex(field.targetField);\n    if (targetIdx === undefined) {\n        throw new Error(`scrt: schema ${schema.name} references unknown field ${field.targetSchema}.${field.targetField}`);\n    }\n    const resolved = resolveFieldKind(doc, targetSchema, targetIdx, stack);\n    field.resolvedKind = resolved;\n    stack.delete(key);\n    if (field.pendingDefault && !field.defaultValue) {\n        field.defaultValue = parseDefaultLiteral(resolved, field.pendingDefault);\n        field.pendingDefault = \"\";\n    }\n    return resolved;\n}\nfunction bytesToBase64(bytes) {\n    if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(bytes).toString(\"base64\");\n    }\n    let binary = \"\";\n    for (let i = 0; i < bytes.length; i += 1) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    if (typeof btoa === \"function\") {\n        return btoa(binary);\n    }\n    throw new Error(\"scrt: base64 encoding unavailable in this environment\");\n}\n","import { createBuffer, pushByte, pushBytes, writeUvarint } from \"./binary\";\nimport { BoolColumn, BytesColumn, Float64Column, Int64Column, StringColumn, Uint64Column } from \"./column\";\nimport { FieldKind } from \"./schema\";\nexport class PageBuilder {\n    schema;\n    rowLimit;\n    columns;\n    columnBuf = createBuffer();\n    rows = 0;\n    constructor(schema, rowLimit = 1024) {\n        this.schema = schema;\n        this.rowLimit = rowLimit;\n        this.columns = schema.fields.map((field) => {\n            const kind = field.valueKind();\n            const handle = { kind, presence: [] };\n            switch (kind) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    handle.uints = new Uint64Column();\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    handle.strings = new StringColumn();\n                    break;\n                case FieldKind.Bool:\n                    handle.bools = new BoolColumn();\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    handle.ints = new Int64Column();\n                    break;\n                case FieldKind.Float64:\n                    handle.floats = new Float64Column();\n                    break;\n                case FieldKind.Bytes:\n                    handle.bytes = new BytesColumn();\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${kind}`);\n            }\n            return handle;\n        });\n    }\n    appendUint(idx, value) {\n        this.columns[idx].uints?.append(value);\n    }\n    appendString(idx, value) {\n        this.columns[idx].strings?.append(value);\n    }\n    appendBool(idx, value) {\n        this.columns[idx].bools?.append(value);\n    }\n    appendInt(idx, value) {\n        this.columns[idx].ints?.append(value);\n    }\n    appendFloat(idx, value) {\n        this.columns[idx].floats?.append(value);\n    }\n    appendBytes(idx, value) {\n        this.columns[idx].bytes?.append(value);\n    }\n    recordPresence(idx, present) {\n        this.columns[idx].presence.push(present);\n    }\n    sealRow() {\n        this.rows += 1;\n        if (this.rows > this.rowLimit) {\n            throw new Error(\"scrt: page builder capacity exceeded\");\n        }\n    }\n    full() {\n        return this.rows >= this.rowLimit;\n    }\n    rowCount() {\n        return this.rows;\n    }\n    reset() {\n        this.rows = 0;\n        for (const column of this.columns) {\n            column.presence.length = 0;\n            column.uints?.reset();\n            column.strings?.reset();\n            column.bools?.reset();\n            column.ints?.reset();\n            column.floats?.reset();\n            column.bytes?.reset();\n        }\n    }\n    encode(dst) {\n        if (this.rows === 0) {\n            return;\n        }\n        writeUvarint(dst, this.rows);\n        writeUvarint(dst, this.columns.length);\n        for (let idx = 0; idx < this.columns.length; idx += 1) {\n            const column = this.columns[idx];\n            this.columnBuf.length = 0;\n            writePresence(this.columnBuf, column.presence, this.rows);\n            switch (column.kind) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    column.uints?.encode(this.columnBuf);\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    column.strings?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Bool:\n                    column.bools?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    column.ints?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Float64:\n                    column.floats?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Bytes:\n                    column.bytes?.encode(this.columnBuf);\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${column.kind}`);\n            }\n            writeUvarint(dst, idx);\n            pushByte(dst, column.kind);\n            writeUvarint(dst, this.columnBuf.length);\n            pushBytes(dst, this.columnBuf);\n        }\n    }\n}\nfunction writePresence(dst, presence, rows) {\n    const byteLen = Math.floor((rows + 7) / 8);\n    writeUvarint(dst, byteLen);\n    if (byteLen === 0) {\n        return;\n    }\n    let current = 0;\n    let shift = 0;\n    let written = 0;\n    for (let row = 0; row < rows; row += 1) {\n        if (presence[row]) {\n            current |= 1 << shift;\n        }\n        shift += 1;\n        if (shift === 8) {\n            pushByte(dst, current);\n            written += 1;\n            current = 0;\n            shift = 0;\n        }\n    }\n    if (shift !== 0) {\n        pushByte(dst, current);\n        written += 1;\n    }\n    while (written < byteLen) {\n        pushByte(dst, 0);\n        written += 1;\n    }\n}\n","import { bufferToUint8Array, createBuffer, pushBytes, writeUvarint } from \"./binary\";\nimport { PageBuilder } from \"./page\";\nimport { FieldKind } from \"./schema\";\nimport { readUvarint, readVarint } from \"./binary\";\nconst MAGIC = \"SCRT\";\nconst VERSION = 2;\nconst textDecoder = new TextDecoder();\nexport class Row {\n    schema;\n    values;\n    constructor(schema) {\n        this.schema = schema;\n        this.values = new Array(schema.fields.length).fill(null).map(() => ({ set: false }));\n    }\n    reset() {\n        for (const value of this.values) {\n            value.set = false;\n            value.uint = undefined;\n            value.int = undefined;\n            value.float = undefined;\n            value.str = undefined;\n            value.bytes = undefined;\n            value.bool = undefined;\n            value.borrowed = undefined;\n        }\n    }\n    setByIndex(idx, value) {\n        this.values[idx] = { ...value, set: true };\n    }\n    valuesSlice() {\n        return this.values;\n    }\n    fieldIndex(name) {\n        return this.schema.fieldIndexByName(name);\n    }\n    setValue(field, value) {\n        this.setByIndex(this.fieldIndex(field), value);\n    }\n    setUint(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.uint = BigInt(value);\n    }\n    setInt(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.int = BigInt(value);\n    }\n    setFloat(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.float = value;\n    }\n    setBool(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.bool = value;\n    }\n    setString(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.str = value;\n    }\n    setBytes(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.bytes = cloneBytes(value);\n    }\n    claimSlot(idx) {\n        const slot = this.values[idx];\n        slot.set = true;\n        slot.uint = undefined;\n        slot.int = undefined;\n        slot.float = undefined;\n        slot.str = undefined;\n        slot.bytes = undefined;\n        slot.bool = undefined;\n        slot.borrowed = false;\n        return slot;\n    }\n}\nexport class Writer {\n    schema;\n    builder;\n    output = createBuffer();\n    headerWritten = false;\n    constructor(schema, rowsPerPage = 1024) {\n        this.schema = schema;\n        this.builder = new PageBuilder(schema, rowsPerPage);\n    }\n    writeRow(row) {\n        if (row.schema !== this.schema) {\n            throw new Error(\"scrt: schema mismatch for row\");\n        }\n        this.ensureHeader();\n        const values = row.valuesSlice();\n        this.schema.fields.forEach((field, idx) => {\n            const value = values[idx];\n            if (!value.set) {\n                this.builder.recordPresence(idx, false);\n                return;\n            }\n            this.builder.recordPresence(idx, true);\n            switch (field.valueKind()) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    this.builder.appendUint(idx, value.uint ?? 0n);\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    this.builder.appendString(idx, value.str ?? \"\");\n                    break;\n                case FieldKind.Bool:\n                    this.builder.appendBool(idx, value.bool ?? false);\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    this.builder.appendInt(idx, value.int ?? 0n);\n                    break;\n                case FieldKind.Float64:\n                    this.builder.appendFloat(idx, value.float ?? 0);\n                    break;\n                case FieldKind.Bytes:\n                    this.builder.appendBytes(idx, value.bytes ?? new Uint8Array());\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${field.valueKind()}`);\n            }\n        });\n        this.builder.sealRow();\n        if (this.builder.full()) {\n            this.flushPage();\n        }\n    }\n    finish() {\n        this.flushPage();\n        return bufferToUint8Array(this.output);\n    }\n    ensureHeader() {\n        if (this.headerWritten) {\n            return;\n        }\n        for (const ch of MAGIC) {\n            this.output.push(ch.charCodeAt(0));\n        }\n        this.output.push(VERSION);\n        const fp = this.schema.fingerprint();\n        const header = new Uint8Array(8);\n        let temp = fp;\n        for (let i = 0; i < 8; i += 1) {\n            header[i] = Number(temp & 0xffn);\n            temp >>= 8n;\n        }\n        pushBytes(this.output, header);\n        this.headerWritten = true;\n    }\n    flushPage() {\n        if (this.builder.rowCount() === 0) {\n            return;\n        }\n        const pageBuf = createBuffer();\n        this.builder.encode(pageBuf);\n        const lenBuf = createBuffer();\n        writeUvarint(lenBuf, pageBuf.length);\n        pushBytes(this.output, lenBuf);\n        pushBytes(this.output, pageBuf);\n        this.builder.reset();\n    }\n}\nclass DecodedPage {\n    rows = 0;\n    cursor = 0;\n    columns;\n    constructor(fieldCount) {\n        this.columns = new Array(fieldCount).fill(null).map(() => ({\n            kind: FieldKind.Invalid,\n            rowIndexes: [],\n            uints: [],\n            stringTable: [],\n            stringIndexes: [],\n            bools: [],\n            ints: [],\n            floats: [],\n            bytes: [],\n        }));\n    }\n}\nexport class Reader {\n    data;\n    schema;\n    options;\n    state;\n    offset = 0;\n    headerRead = false;\n    constructor(data, schema, options = {}) {\n        this.data = data;\n        this.schema = schema;\n        this.options = options;\n        this.state = new DecodedPage(schema.fields.length);\n    }\n    readRow(row) {\n        if (!this.headerRead && !this.consumeHeader()) {\n            return false;\n        }\n        if (this.state.cursor >= this.state.rows) {\n            if (!this.loadPage()) {\n                return false;\n            }\n        }\n        const rowIdx = this.state.cursor;\n        const values = row.valuesSlice();\n        for (let fieldIdx = 0; fieldIdx < this.schema.fields.length; fieldIdx += 1) {\n            const field = this.schema.fields[fieldIdx];\n            const column = this.state.columns[fieldIdx];\n            const valueSlot = values[fieldIdx];\n            const valueIdx = column.rowIndexes[rowIdx] ?? -1;\n            if (valueIdx < 0) {\n                assignDefaultValue(field, valueSlot);\n                continue;\n            }\n            valueSlot.set = true;\n            switch (field.valueKind()) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    valueSlot.uint = column.uints[valueIdx];\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    valueSlot.str = column.stringTable[column.stringIndexes[valueIdx] ?? 0] ?? \"\";\n                    break;\n                case FieldKind.Bool:\n                    valueSlot.bool = column.bools[valueIdx];\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    valueSlot.int = column.ints[valueIdx];\n                    break;\n                case FieldKind.Float64:\n                    valueSlot.float = column.floats[valueIdx];\n                    break;\n                case FieldKind.Bytes:\n                    valueSlot.bytes = column.bytes[valueIdx];\n                    valueSlot.borrowed = this.options.zeroCopyBytes ?? false;\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${field.valueKind()}`);\n            }\n        }\n        this.state.cursor += 1;\n        return true;\n    }\n    consumeHeader() {\n        if (this.data.length < MAGIC.length + 1 + 8) {\n            return false;\n        }\n        const magic = textDecoder.decode(this.data.subarray(0, MAGIC.length));\n        if (magic !== MAGIC) {\n            throw new Error(\"scrt: invalid stream header\");\n        }\n        const version = this.data[MAGIC.length];\n        if (version !== VERSION) {\n            throw new Error(`scrt: unsupported version ${version}`);\n        }\n        const fpBytes = this.data.subarray(MAGIC.length + 1, MAGIC.length + 9);\n        let fp = 0n;\n        for (let i = 7; i >= 0; i -= 1) {\n            fp = (fp << 8n) | BigInt(fpBytes[i]);\n        }\n        if (fp !== this.schema.fingerprint()) {\n            throw new Error(\"scrt: schema fingerprint mismatch\");\n        }\n        this.offset = MAGIC.length + 9;\n        this.headerRead = true;\n        return true;\n    }\n    loadPage() {\n        if (this.offset >= this.data.length) {\n            return false;\n        }\n        const { value: length, bytesRead } = readUvarint(this.data, this.offset);\n        this.offset += bytesRead;\n        const pageLength = Number(length);\n        if (pageLength === 0 || this.offset + pageLength > this.data.length) {\n            return false;\n        }\n        const raw = this.data.subarray(this.offset, this.offset + pageLength);\n        this.offset += pageLength;\n        this.decodePage(raw);\n        return true;\n    }\n    decodePage(raw) {\n        let cursor = 0;\n        const { value: rows, bytesRead: rowsRead } = readUvarint(raw, cursor);\n        cursor += rowsRead;\n        const rowCount = Number(rows);\n        const { value: columns, bytesRead: columnsRead } = readUvarint(raw, cursor);\n        cursor += columnsRead;\n        const columnCount = Number(columns);\n        if (columnCount !== this.schema.fields.length) {\n            throw new Error(\"scrt: column count mismatch\");\n        }\n        this.state.rows = rowCount;\n        this.state.cursor = 0;\n        for (let i = 0; i < columnCount; i += 1) {\n            const { value: fieldIdxBig, bytesRead: fieldIdxRead } = readUvarint(raw, cursor);\n            cursor += fieldIdxRead;\n            const fieldIdx = Number(fieldIdxBig);\n            const kind = raw[cursor];\n            cursor += 1;\n            const { value: payloadLen, bytesRead: payloadLenRead } = readUvarint(raw, cursor);\n            cursor += payloadLenRead;\n            const payload = raw.subarray(cursor, cursor + Number(payloadLen));\n            cursor += Number(payloadLen);\n            this.decodeColumn(fieldIdx, kind, payload, rowCount);\n        }\n    }\n    decodeColumn(idx, kind, payload, rows) {\n        const column = this.state.columns[idx];\n        column.kind = kind;\n        const presence = decodePresence(payload, rows);\n        column.rowIndexes = presence.indexes;\n        const buffer = payload.subarray(presence.bytesRead);\n        switch (kind) {\n            case FieldKind.Uint64:\n            case FieldKind.Ref: {\n                const decoded = decodeUintColumn(buffer, presence.setCount);\n                column.uints = decoded.values;\n                break;\n            }\n            case FieldKind.String:\n            case FieldKind.TimestampTZ: {\n                const decoded = decodeStringColumn(buffer, presence.setCount);\n                column.stringTable = decoded.table;\n                column.stringIndexes = decoded.indexes;\n                break;\n            }\n            case FieldKind.Bool: {\n                const decoded = decodeBoolColumn(buffer, presence.setCount);\n                column.bools = decoded.values;\n                break;\n            }\n            case FieldKind.Int64:\n            case FieldKind.Date:\n            case FieldKind.DateTime:\n            case FieldKind.Timestamp:\n            case FieldKind.Duration: {\n                const decoded = decodeIntColumn(buffer, presence.setCount);\n                column.ints = decoded.values;\n                break;\n            }\n            case FieldKind.Float64: {\n                const decoded = decodeFloatColumn(buffer, presence.setCount);\n                column.floats = decoded.values;\n                break;\n            }\n            case FieldKind.Bytes: {\n                const decoded = decodeBytesColumn(buffer, presence.setCount, this.options.zeroCopyBytes ?? false);\n                column.bytes = decoded.values;\n                break;\n            }\n            default:\n                throw new Error(`scrt: unsupported field kind ${kind}`);\n        }\n    }\n}\nfunction decodePresence(data, rows) {\n    const { value: byteLenBig, bytesRead } = readUvarint(data, 0);\n    const byteLen = Number(byteLenBig);\n    let cursor = bytesRead;\n    const indexes = new Array(rows).fill(-1);\n    let setCount = 0;\n    for (let row = 0; row < rows; row += 1) {\n        const byteIdx = Math.floor(row / 8);\n        const bit = row % 8;\n        if (byteIdx < byteLen) {\n            const present = (data[cursor + byteIdx] & (1 << bit)) !== 0;\n            if (present) {\n                indexes[row] = setCount;\n                setCount += 1;\n            }\n        }\n    }\n    cursor += byteLen;\n    return { indexes, setCount, bytesRead: cursor };\n}\nfunction decodeUintColumn(data, expected) {\n    let cursor = 0;\n    const { value: header, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const mode = header & 1n;\n    const count = Number(header >> 1n);\n    if (count !== expected) {\n        throw new Error(\"scrt: uint column count mismatch\");\n    }\n    const values = new Array(count).fill(0n);\n    if (count === 0) {\n        return { values };\n    }\n    if (mode === 0n) {\n        for (let i = 0; i < count; i += 1) {\n            const result = readUvarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = result.value;\n        }\n    }\n    else {\n        let result = readUvarint(data, cursor);\n        cursor += result.bytesRead;\n        values[0] = result.value;\n        for (let i = 1; i < count; i += 1) {\n            result = readUvarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = values[i - 1] + result.value;\n        }\n    }\n    return { values };\n}\nfunction decodeIntColumn(data, expected) {\n    let cursor = 0;\n    const { value: header, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const mode = header & 1n;\n    const count = Number(header >> 1n);\n    if (count !== expected) {\n        throw new Error(\"scrt: int column count mismatch\");\n    }\n    const values = new Array(count).fill(0n);\n    if (count === 0) {\n        return { values };\n    }\n    if (mode === 0n) {\n        for (let i = 0; i < count; i += 1) {\n            const result = readVarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = result.value;\n        }\n    }\n    else {\n        let result = readVarint(data, cursor);\n        cursor += result.bytesRead;\n        values[0] = result.value;\n        for (let i = 1; i < count; i += 1) {\n            result = readVarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = values[i - 1] + result.value;\n        }\n    }\n    return { values };\n}\nfunction decodeFloatColumn(data, expected) {\n    let cursor = 0;\n    const { value: countBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const count = Number(countBig);\n    if (count !== expected) {\n        throw new Error(\"scrt: float column count mismatch\");\n    }\n    const values = new Array(count).fill(0);\n    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    for (let i = 0; i < count; i += 1) {\n        if (cursor + 8 > data.length) {\n            throw new Error(\"scrt: float column truncated\");\n        }\n        values[i] = view.getFloat64(cursor, true);\n        cursor += 8;\n    }\n    return { values };\n}\nfunction decodeBoolColumn(data, expected) {\n    let cursor = 0;\n    const { value: countBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const count = Number(countBig);\n    if (count !== expected) {\n        throw new Error(\"scrt: bool column count mismatch\");\n    }\n    const values = new Array(count);\n    for (let i = 0; i < count; i += 1) {\n        values[i] = data[cursor + i] !== 0;\n    }\n    return { values };\n}\nfunction decodeStringColumn(data, expected) {\n    let cursor = 0;\n    const { value: dictLenBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const dictLen = Number(dictLenBig);\n    const table = new Array(dictLen);\n    for (let i = 0; i < dictLen; i += 1) {\n        const lengthInfo = readUvarint(data, cursor);\n        cursor += lengthInfo.bytesRead;\n        const length = Number(lengthInfo.value);\n        const slice = data.subarray(cursor, cursor + length);\n        table[i] = textDecoder.decode(slice);\n        cursor += length;\n    }\n    const { value: indexLenBig, bytesRead: indexRead } = readUvarint(data, cursor);\n    cursor += indexRead;\n    const indexLen = Number(indexLenBig);\n    if (indexLen !== expected) {\n        throw new Error(\"scrt: string index count mismatch\");\n    }\n    const indexes = new Array(indexLen);\n    for (let i = 0; i < indexLen; i += 1) {\n        const idxInfo = readUvarint(data, cursor);\n        cursor += idxInfo.bytesRead;\n        indexes[i] = Number(idxInfo.value);\n    }\n    return { table, indexes };\n}\nfunction decodeBytesColumn(data, expected, zeroCopy) {\n    let cursor = 0;\n    const { value: countBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const count = Number(countBig);\n    if (count !== expected) {\n        throw new Error(\"scrt: bytes column count mismatch\");\n    }\n    const values = new Array(count);\n    for (let i = 0; i < count; i += 1) {\n        const lengthInfo = readUvarint(data, cursor);\n        cursor += lengthInfo.bytesRead;\n        const length = Number(lengthInfo.value);\n        const slice = data.subarray(cursor, cursor + length);\n        values[i] = zeroCopy ? slice : cloneBytes(slice);\n        cursor += length;\n    }\n    return { values };\n}\nfunction cloneBytes(src) {\n    const copy = new Uint8Array(src.length);\n    copy.set(src);\n    return copy;\n}\nfunction assignDefaultValue(field, slot) {\n    slot.set = false;\n    const def = field.defaultValue;\n    if (!def) {\n        return;\n    }\n    slot.set = true;\n    switch (def.kind) {\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            slot.uint = def.uintValue ?? 0n;\n            break;\n        case FieldKind.Int64:\n        case FieldKind.Date:\n        case FieldKind.DateTime:\n        case FieldKind.Timestamp:\n        case FieldKind.Duration:\n            slot.int = def.intValue ?? 0n;\n            break;\n        case FieldKind.Float64:\n            slot.float = def.floatValue ?? 0;\n            break;\n        case FieldKind.Bool:\n            slot.bool = def.boolValue ?? false;\n            break;\n        case FieldKind.String:\n        case FieldKind.TimestampTZ:\n            slot.str = def.stringValue ?? \"\";\n            break;\n        case FieldKind.Bytes:\n            slot.bytes = def.bytesValue ? cloneBytes(def.bytesValue) : new Uint8Array();\n            break;\n        default:\n            slot.set = false;\n    }\n}\n","import { Reader, Row, Writer } from \"./codec\";\nimport { FieldKind } from \"./schema\";\nimport { canonicalTimestampTZ, decodeDate, decodeInstant, encodeDate, encodeInstant, formatDate, formatDuration, formatInstant, formatTimestampTZ, inferEpochNanoseconds, parseDate, parseDateTime, parseDuration, parseTimestamp, parseTimestampTZ, } from \"./temporal\";\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport function marshalRecords(schema, source, options = {}) {\n    if (!schema) {\n        throw new Error(\"scrt: schema is required for marshal\");\n    }\n    const writer = new Writer(schema, options.rowsPerPage ?? 1024);\n    const scratch = new Row(schema);\n    for (const record of toIterable(source)) {\n        if (record instanceof Row) {\n            if (record.schema !== schema) {\n                throw new Error(\"scrt: row schema mismatch during marshal\");\n            }\n            writer.writeRow(record);\n            continue;\n        }\n        if (!isRecordShape(record)) {\n            throw new Error(\"scrt: marshal expects plain objects, maps, or Row instances\");\n        }\n        populateRow(scratch, schema, record);\n        writer.writeRow(scratch);\n    }\n    return writer.finish();\n}\nexport function unmarshalRecords(source, schema, options) {\n    const results = [];\n    for (const record of streamDecodedRows(source, schema, options)) {\n        results.push(record);\n    }\n    return results;\n}\nexport function* streamDecodedRows(source, schema, options) {\n    if (!schema) {\n        throw new Error(\"scrt: schema is required for unmarshal\");\n    }\n    const resolved = resolveUnmarshalOptions(options);\n    const reader = new Reader(normalizeBinarySource(source), schema, { zeroCopyBytes: resolved.zeroCopyBytes });\n    const row = new Row(schema);\n    while (reader.readRow(row)) {\n        const materialized = materializeRow(row, schema, resolved);\n        yield materialized;\n        row.reset();\n    }\n}\nfunction toIterable(source) {\n    if (isIterable(source)) {\n        return source;\n    }\n    return [source];\n}\nfunction isIterable(value) {\n    if (value == null) {\n        return false;\n    }\n    if (typeof value === \"string\") {\n        return false;\n    }\n    const candidate = value;\n    return typeof candidate[Symbol.iterator] === \"function\";\n}\nfunction isRecordShape(value) {\n    if (value instanceof Map) {\n        return true;\n    }\n    if (value instanceof Date) {\n        return false;\n    }\n    if (value && typeof value === \"object\") {\n        if (Array.isArray(value)) {\n            return false;\n        }\n        if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction populateRow(row, schema, record) {\n    row.reset();\n    const accessor = createAccessor(record);\n    schema.fields.forEach((field, idx) => {\n        const raw = accessor(field.name);\n        if (raw === undefined || raw === null) {\n            return;\n        }\n        const encoded = encodeFieldValue(field, raw);\n        if (encoded) {\n            row.setByIndex(idx, encoded);\n        }\n    });\n}\nfunction createAccessor(record) {\n    if (record instanceof Map) {\n        return (field) => record.get(field);\n    }\n    return (field) => record[field];\n}\nfunction encodeFieldValue(field, raw) {\n    if (raw === undefined || raw === null) {\n        return null;\n    }\n    const kind = field.valueKind();\n    const slot = { set: true };\n    switch (kind) {\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            slot.uint = coerceUint(raw, field.name);\n            return slot;\n        case FieldKind.Int64:\n            slot.int = coerceInt(raw, field.name);\n            return slot;\n        case FieldKind.Float64:\n            slot.float = coerceFloat(raw, field.name);\n            return slot;\n        case FieldKind.Bool:\n            slot.bool = coerceBool(raw, field.name);\n            return slot;\n        case FieldKind.String:\n            slot.str = coerceString(raw, field.name);\n            return slot;\n        case FieldKind.Bytes:\n            slot.bytes = coerceBytes(raw, field.name);\n            return slot;\n        case FieldKind.Date:\n            slot.int = encodeDate(coerceDate(raw, field.name, FieldKind.Date));\n            return slot;\n        case FieldKind.DateTime:\n        case FieldKind.Timestamp:\n            slot.int = encodeInstant(coerceDate(raw, field.name, kind));\n            return slot;\n        case FieldKind.TimestampTZ:\n            slot.str = coerceTimestampTZ(raw, field.name);\n            return slot;\n        case FieldKind.Duration:\n            slot.int = coerceDuration(raw, field.name);\n            return slot;\n        default:\n            throw new Error(`scrt: unsupported field kind ${kind} for ${field.name}`);\n    }\n}\nfunction coerceUint(value, label) {\n    const result = coerceInt(value, label);\n    if (result < 0n) {\n        throw new Error(`scrt: ${label} cannot be negative`);\n    }\n    return result;\n}\nfunction coerceInt(value, label) {\n    if (typeof value === \"bigint\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value) || !Number.isInteger(value)) {\n            throw new Error(`scrt: ${label} must be a finite integer`);\n        }\n        if (Math.abs(value) > Number.MAX_SAFE_INTEGER) {\n            throw new Error(`scrt: ${label} exceeds safe integer range`);\n        }\n        return BigInt(value);\n    }\n    if (typeof value === \"string\") {\n        const trimmed = value.trim();\n        if (!trimmed) {\n            throw new Error(`scrt: ${label} cannot be empty`);\n        }\n        return BigInt(trimmed);\n    }\n    throw new Error(`scrt: ${label} expects an integer-compatible value`);\n}\nfunction coerceFloat(value, label) {\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return value;\n    }\n    if (typeof value === \"bigint\") {\n        return Number(value);\n    }\n    if (typeof value === \"string\") {\n        const parsed = Number(value.trim());\n        if (Number.isNaN(parsed)) {\n            throw new Error(`scrt: ${label} cannot parse float literal`);\n        }\n        return parsed;\n    }\n    throw new Error(`scrt: ${label} expects a float-compatible value`);\n}\nfunction coerceBool(value, label) {\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return value !== 0;\n    }\n    if (typeof value === \"string\") {\n        const normalized = value.trim().toLowerCase();\n        if (normalized === \"true\" || normalized === \"1\") {\n            return true;\n        }\n        if (normalized === \"false\" || normalized === \"0\") {\n            return false;\n        }\n        throw new Error(`scrt: ${label} cannot parse boolean literal`);\n    }\n    throw new Error(`scrt: ${label} expects a boolean-compatible value`);\n}\nfunction coerceString(value, label) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"bigint\") {\n        return String(value);\n    }\n    if (value instanceof Date) {\n        if (!Number.isFinite(value.getTime())) {\n            throw new Error(`scrt: ${label} received invalid Date`);\n        }\n        return value.toISOString();\n    }\n    if (value instanceof Uint8Array) {\n        return textDecoder.decode(value);\n    }\n    throw new Error(`scrt: ${label} expects a string-compatible value`);\n}\nfunction coerceBytes(value, label) {\n    if (value instanceof Uint8Array) {\n        return value.slice();\n    }\n    if (ArrayBuffer.isView(value)) {\n        const view = value;\n        return new Uint8Array(view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength));\n    }\n    if (value instanceof ArrayBuffer) {\n        return new Uint8Array(value.slice(0));\n    }\n    if (Array.isArray(value)) {\n        const out = new Uint8Array(value.length);\n        value.forEach((entry, idx) => {\n            if (typeof entry !== \"number\" || !Number.isFinite(entry)) {\n                throw new Error(`scrt: ${label} byte array contains non-number at index ${idx}`);\n            }\n            out[idx] = entry & 0xff;\n        });\n        return out;\n    }\n    if (typeof value === \"string\") {\n        return textEncoder.encode(value);\n    }\n    throw new Error(`scrt: ${label} expects bytes, ArrayBufferView, or string input`);\n}\nfunction coerceDate(value, label, kind) {\n    if (value instanceof Date) {\n        if (!Number.isFinite(value.getTime())) {\n            throw new Error(`scrt: ${label} received invalid Date`);\n        }\n        return value;\n    }\n    if (typeof value === \"string\") {\n        const trimmed = value.trim();\n        if (!trimmed) {\n            throw new Error(`scrt: ${label} cannot parse empty temporal literal`);\n        }\n        switch (kind) {\n            case FieldKind.Date:\n                return parseDate(trimmed);\n            case FieldKind.DateTime:\n                return parseDateTime(trimmed);\n            case FieldKind.Timestamp:\n                return parseTimestamp(trimmed);\n            default:\n                return parseTimestamp(trimmed);\n        }\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return dateFromNumber(value);\n    }\n    if (typeof value === \"bigint\") {\n        return dateFromBigInt(value);\n    }\n    throw new Error(`scrt: ${label} expects Date, number, bigint, or string`);\n}\nfunction coerceTimestampTZ(value, label) {\n    if (value instanceof Date) {\n        if (!Number.isFinite(value.getTime())) {\n            throw new Error(`scrt: ${label} received invalid Date`);\n        }\n        return formatTimestampTZ(value);\n    }\n    if (typeof value === \"string\") {\n        return canonicalTimestampTZ(value);\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return formatTimestampTZ(dateFromNumber(value));\n    }\n    if (typeof value === \"bigint\") {\n        return formatTimestampTZ(dateFromBigInt(value));\n    }\n    throw new Error(`scrt: ${label} expects Date, number, bigint, or string`);\n}\nfunction coerceDuration(value, label) {\n    if (typeof value === \"bigint\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value) || !Number.isInteger(value)) {\n            throw new Error(`scrt: ${label} duration must be a finite integer`);\n        }\n        if (Math.abs(value) > Number.MAX_SAFE_INTEGER) {\n            throw new Error(`scrt: ${label} duration exceeds safe integer range`);\n        }\n        return BigInt(value);\n    }\n    if (typeof value === \"string\") {\n        return parseDuration(value);\n    }\n    throw new Error(`scrt: ${label} expects bigint, number, or duration literal`);\n}\nfunction dateFromNumber(value) {\n    if (Number.isInteger(value)) {\n        return decodeInstant(inferEpochNanoseconds(BigInt(value)));\n    }\n    const whole = Math.trunc(value);\n    const fractional = value - whole;\n    const nanos = BigInt(whole) * 1000000000n + BigInt(Math.trunc(fractional * 1_000_000_000));\n    return decodeInstant(nanos);\n}\nfunction dateFromBigInt(value) {\n    return decodeInstant(inferEpochNanoseconds(value));\n}\nfunction normalizeBinarySource(source) {\n    if (source instanceof Uint8Array) {\n        return source;\n    }\n    if (ArrayBuffer.isView(source)) {\n        const view = source;\n        return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n    }\n    if (source instanceof ArrayBuffer) {\n        return new Uint8Array(source);\n    }\n    throw new Error(\"scrt: unsupported binary source\");\n}\nfunction resolveUnmarshalOptions(options) {\n    return {\n        zeroCopyBytes: options?.zeroCopyBytes ?? false,\n        numericMode: options?.numericMode ?? \"auto\",\n        temporalMode: options?.temporalMode ?? \"date\",\n        durationMode: options?.durationMode ?? \"bigint\",\n        objectFactory: options?.objectFactory ?? (() => ({})),\n    };\n}\nfunction materializeRow(row, schema, options) {\n    const target = options.objectFactory();\n    const values = row.valuesSlice();\n    schema.fields.forEach((field, idx) => {\n        const slot = values[idx];\n        if (!slot.set) {\n            return;\n        }\n        const decoded = decodeFieldValue(field, slot, options);\n        assignToTarget(target, field.name, decoded);\n    });\n    return target;\n}\nfunction assignToTarget(target, key, value) {\n    if (target instanceof Map) {\n        target.set(key, value);\n        return;\n    }\n    target[key] = value;\n}\nfunction decodeFieldValue(field, slot, options) {\n    const kind = field.valueKind();\n    switch (kind) {\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            return convertBigInt(slot.uint ?? 0n, options.numericMode, field.name, true);\n        case FieldKind.Int64:\n            return convertBigInt(slot.int ?? 0n, options.numericMode, field.name, false);\n        case FieldKind.Float64:\n            return slot.float ?? 0;\n        case FieldKind.Bool:\n            return slot.bool ?? false;\n        case FieldKind.String:\n            return slot.str ?? \"\";\n        case FieldKind.Bytes:\n            return slot.bytes ?? new Uint8Array();\n        case FieldKind.Date: {\n            const decoded = decodeDate(slot.int ?? 0n);\n            return options.temporalMode === \"string\" ? formatDate(decoded) : decoded;\n        }\n        case FieldKind.DateTime:\n        case FieldKind.Timestamp: {\n            const decoded = decodeInstant(slot.int ?? 0n);\n            return options.temporalMode === \"string\" ? formatInstant(decoded) : decoded;\n        }\n        case FieldKind.TimestampTZ: {\n            const str = slot.str ?? \"\";\n            if (!str) {\n                return options.temporalMode === \"date\" ? new Date(0) : \"\";\n            }\n            if (options.temporalMode === \"string\") {\n                return str;\n            }\n            return parseTimestampTZ(str);\n        }\n        case FieldKind.Duration:\n            return convertDuration(slot.int ?? 0n, options.durationMode, field.name);\n        default:\n            throw new Error(`scrt: unsupported field kind ${kind}`);\n    }\n}\nfunction convertBigInt(value, mode, label, unsigned) {\n    if (unsigned && value < 0n) {\n        throw new Error(`scrt: ${label} stored value cannot be negative`);\n    }\n    switch (mode) {\n        case \"bigint\":\n            return value;\n        case \"number\":\n            if (!fitsSafeInteger(value)) {\n                throw new Error(`scrt: ${label} exceeds JS safe integer range`);\n            }\n            return Number(value);\n        default:\n            return fitsSafeInteger(value) ? Number(value) : value;\n    }\n}\nfunction convertDuration(value, mode, label) {\n    switch (mode) {\n        case \"bigint\":\n            return value;\n        case \"number\":\n            if (!fitsSafeInteger(value)) {\n                throw new Error(`scrt: duration ${label} exceeds JS safe integer range`);\n            }\n            return Number(value);\n        case \"string\":\n            return formatDuration(value);\n        default:\n            return value;\n    }\n}\nfunction fitsSafeInteger(value) {\n    return value <= BigInt(Number.MAX_SAFE_INTEGER) && value >= BigInt(Number.MIN_SAFE_INTEGER);\n}\n","const textDecoder = new TextDecoder();\nconst MAGIC = \"SCB1\";\nconst VERSION = 1;\nexport function decodeBundle(buffer) {\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < MAGIC.length; i += 1) {\n        if (view.getUint8(offset) !== MAGIC.charCodeAt(i)) {\n            throw new Error(\"scrt: invalid bundle magic\");\n        }\n        offset += 1;\n    }\n    const version = view.getUint8(offset);\n    offset += 1;\n    if (version !== VERSION) {\n        throw new Error(`scrt: unsupported bundle version ${version}`);\n    }\n    const docFingerprint = view.getBigUint64(offset, true);\n    offset += 8;\n    const schemaFingerprint = view.getBigUint64(offset, true);\n    offset += 8;\n    const updatedAt = new Date(Number(view.getBigInt64(offset, true) / 1000000n));\n    offset += 8;\n    const docString = readShortString(view, buffer, offset);\n    offset += docString.bytes;\n    const schemaString = readShortString(view, buffer, offset);\n    offset += schemaString.bytes;\n    const schemaBlob = readBlob(view, buffer, offset);\n    offset += schemaBlob.bytes;\n    const payload = readBlob(view, buffer, offset);\n    return {\n        documentName: docString.value,\n        schemaName: schemaString.value,\n        documentFingerprint: docFingerprint,\n        schemaFingerprint,\n        updatedAt,\n        schemaText: textDecoder.decode(schemaBlob.data),\n        payload: payload.data,\n    };\n}\nfunction readShortString(view, buffer, offset) {\n    const length = view.getUint16(offset, true);\n    const start = offset + 2;\n    const end = start + length;\n    if (end > buffer.byteLength) {\n        throw new Error(\"scrt: bundle string exceeds buffer\");\n    }\n    return { value: textDecoder.decode(buffer.slice(start, end)), bytes: 2 + length };\n}\nfunction readBlob(view, buffer, offset) {\n    const length = view.getUint32(offset, true);\n    const start = offset + 4;\n    const end = start + length;\n    if (end > buffer.byteLength) {\n        throw new Error(\"scrt: bundle blob exceeds buffer\");\n    }\n    return { data: new Uint8Array(buffer.slice(start, end)), bytes: 4 + length };\n}\n","import { decodeBundle } from \"./protocol\";\nfunction normalizeBase(url) {\n    const trimmed = url.trim();\n    if (!trimmed) {\n        return \"http://localhost:8080\";\n    }\n    return trimmed.endsWith(\"/\") ? trimmed.slice(0, -1) : trimmed;\n}\nasync function ensureOk(resp) {\n    if (resp.ok) {\n        return resp;\n    }\n    const text = await resp.text();\n    throw new Error(text || resp.statusText);\n}\nexport class ScrtHttpClient {\n    baseUrl;\n    constructor(baseUrl = \"http://localhost:8080\") {\n        this.baseUrl = normalizeBase(baseUrl);\n    }\n    setBaseUrl(url) {\n        this.baseUrl = normalizeBase(url);\n    }\n    url(path) {\n        return `${this.baseUrl}${path}`;\n    }\n    async listDocuments() {\n        const resp = await ensureOk(await fetch(this.url(\"/documents\"), {\n            headers: { Accept: \"text/plain\" },\n        }));\n        const body = await resp.text();\n        return body\n            .split(/\\r?\\n/)\n            .map((line) => line.trim())\n            .filter(Boolean);\n    }\n    async downloadDocument(name) {\n        const resp = await ensureOk(await fetch(this.url(`/documents/${encodeURIComponent(name)}`), {\n            headers: { Accept: \"text/plain\" },\n        }));\n        return resp.text();\n    }\n    async saveDocument(name, body) {\n        await ensureOk(await fetch(this.url(`/documents/${encodeURIComponent(name)}`), {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"text/plain; charset=utf-8\" },\n            body,\n        }));\n    }\n    async deleteDocument(name) {\n        await ensureOk(await fetch(this.url(`/documents/${encodeURIComponent(name)}`), {\n            method: \"DELETE\",\n        }));\n    }\n    async uploadRecords(doc, schema, payload) {\n        await ensureOk(await fetch(this.url(`/records/${encodeURIComponent(doc)}/${encodeURIComponent(schema)}`), {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/x-scrt\" },\n            body: payload,\n        }));\n    }\n    async fetchRecords(doc, schema) {\n        const resp = await ensureOk(await fetch(this.url(`/records/${encodeURIComponent(doc)}/${encodeURIComponent(schema)}`)));\n        const buffer = await resp.arrayBuffer();\n        return new Uint8Array(buffer);\n    }\n    async fetchBundle(doc, schema) {\n        const resp = await ensureOk(await fetch(this.url(`/bundle?document=${encodeURIComponent(doc)}&schema=${encodeURIComponent(schema)}`)));\n        const buffer = await resp.arrayBuffer();\n        return decodeBundle(buffer);\n    }\n}\n"],"names":["createBuffer","bufferLength","buf","pushByte","byte","pushBytes","bytes","i","bufferToUint8Array","concatByteBuffers","buffers","total","acc","cur","out","offset","MAX_VARINT_BYTES","writeUvarint","value","v","writeVarint","uv","zigZagEncode","readUvarint","data","x","s","b","readVarint","bytesRead","zigZagDecode","BinaryWriter","__publicField","buffer","arr","BinaryReader","size","length","slice","toSafeNumber","label","encodeUint64LE","temp","encoder","Uint64Column","dst","count","mode","isMonotonic","header","prev","delta","Int64Column","Float64Column","writeFloat64","BoolColumn","StringColumn","entry","idx","BytesColumn","copy","values","view","ISO_DATE","ISO_DATE_TIME","NUMERIC","DURATION_TOKEN","NANOS","parseDate","raw","trimmed","iso","parsed","utcDate","year","month","day","parseDateTime","match","y","m","d","hh","mm","ss","frac","nanos","normalizeFraction","date","parseTimestamp","numericTimestamp","parseTimestampTZ","parseDuration","matched","token","unitRaw","unit","scale","whole","fracScale","powerOfTen","encodeInstant","encodeDate","midnight","formatTimestampTZ","canonicalTimestampTZ","decodeInstant","ns","ms","decodeDate","formatDate","formatInstant","sec","fracDigits","inferEpochNanoseconds","abs","DURATION_UNITS","formatDuration","negative","remaining","chunks","input","digits","exp","result","FNV_OFFSET","FNV_PRIME","FieldKind","DefaultValue","kind","boolValue","intValue","uintValue","floatValue","stringValue","bytesValue","bytesToBase64","Field","name","rawType","targetSchema","targetField","autoIncrement","attributes","defaultValue","Schema","fields","hash","write","str","field","attrs","attr","Document","schemas","source","schema","resolveSchemaKinds","parseSchema","text","lines","line","current","awaitingName","currentData","finishCurrent","startSchema","rest","parseField","sch","row","parseDataRow","pushDataRow","doc","store","schemaName","body","typ","attrChunk","splitFieldParts","interpretFieldType","splitFieldAttributes","lower","assignFieldDefault","extractDefaultLiteral","firstSep","secondSep","fieldName","quote","ch","literalRaw","literal","parseDefaultLiteral","sepIdx","parseStringLiteral","parseBytesLiteral","stripQuotes","ts","hex","tokens","fieldIdx","countValueTokens","skipAuto","nonAuto","countNonAuto","index","applyExplicitAssignment","parseValue","start","expr","fieldToken","rawValue","normalized","normalizeAssignmentTarget","parts","resolveFieldKind","stack","key","targetIdx","resolved","binary","PageBuilder","rowLimit","handle","_a","present","_b","_c","_d","_e","_f","column","writePresence","presence","rows","byteLen","shift","written","MAGIC","VERSION","textDecoder","Row","slot","cloneBytes","Writer","rowsPerPage","fp","pageBuf","lenBuf","DecodedPage","fieldCount","Reader","options","rowIdx","valueSlot","valueIdx","assignDefaultValue","version","fpBytes","pageLength","cursor","rowsRead","rowCount","columns","columnsRead","columnCount","fieldIdxBig","fieldIdxRead","payloadLen","payloadLenRead","payload","decodePresence","decoded","decodeUintColumn","decodeStringColumn","decodeBoolColumn","decodeIntColumn","decodeFloatColumn","decodeBytesColumn","byteLenBig","indexes","setCount","byteIdx","bit","expected","countBig","dictLenBig","dictLen","table","lengthInfo","indexLenBig","indexRead","indexLen","idxInfo","zeroCopy","src","def","textEncoder","marshalRecords","writer","scratch","record","toIterable","isRecordShape","populateRow","unmarshalRecords","results","streamDecodedRows","resolveUnmarshalOptions","reader","normalizeBinarySource","materializeRow","isIterable","accessor","createAccessor","encoded","encodeFieldValue","coerceUint","coerceInt","coerceFloat","coerceBool","coerceString","coerceBytes","coerceDate","coerceTimestampTZ","coerceDuration","dateFromNumber","dateFromBigInt","fractional","target","decodeFieldValue","assignToTarget","convertBigInt","convertDuration","unsigned","fitsSafeInteger","decodeBundle","docFingerprint","schemaFingerprint","updatedAt","docString","readShortString","schemaString","schemaBlob","readBlob","end","normalizeBase","url","ensureOk","resp","ScrtHttpClient","baseUrl","path"],"mappings":"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"}