{"version":3,"file":"scrt.cjs.js","sources":["../src/binary.js","../src/column.js","../src/temporal.js","../src/schema.js","../src/page.js","../src/codec.js","../src/marshal.js","../src/protocol.js","../src/client.js"],"sourcesContent":["export function createBuffer() {\n    return [];\n}\nexport function bufferLength(buf) {\n    return buf.length;\n}\nexport function pushByte(buf, byte) {\n    buf.push(byte & 0xff);\n}\nexport function pushBytes(buf, bytes) {\n    for (let i = 0; i < bytes.length; i += 1) {\n        buf.push(bytes[i] & 0xff);\n    }\n}\nexport function bufferToUint8Array(buf) {\n    return Uint8Array.from(buf);\n}\nexport function concatByteBuffers(buffers) {\n    const total = buffers.reduce((acc, cur) => acc + cur.length, 0);\n    const out = new Uint8Array(total);\n    let offset = 0;\n    for (const buf of buffers) {\n        out.set(Uint8Array.from(buf), offset);\n        offset += buf.length;\n    }\n    return out;\n}\nconst MAX_VARINT_BYTES = 10;\nexport function writeUvarint(buf, value) {\n    let v = BigInt(value);\n    if (v < 0n) {\n        throw new RangeError(\"uvarint cannot be negative\");\n    }\n    while (v >= 0x80n) {\n        pushByte(buf, Number((v & 0x7fn) | 0x80n));\n        v >>= 7n;\n    }\n    pushByte(buf, Number(v));\n}\nexport function writeVarint(buf, value) {\n    let uv = zigZagEncode(BigInt(value));\n    while (uv >= 0x80n) {\n        pushByte(buf, Number((uv & 0x7fn) | 0x80n));\n        uv >>= 7n;\n    }\n    pushByte(buf, Number(uv));\n}\nexport function readUvarint(data, offset) {\n    let x = 0n;\n    let s = 0n;\n    for (let i = 0; i < MAX_VARINT_BYTES; i += 1) {\n        if (offset + i >= data.length) {\n            throw new RangeError(\"uvarint exceeds buffer\");\n        }\n        const b = BigInt(data[offset + i]);\n        if ((b & 0x80n) === 0n) {\n            x |= (b & 0x7fn) << s;\n            return { value: x, bytesRead: i + 1 };\n        }\n        x |= (b & 0x7fn) << s;\n        s += 7n;\n    }\n    throw new RangeError(\"uvarint too large\");\n}\nexport function readVarint(data, offset) {\n    const { value, bytesRead } = readUvarint(data, offset);\n    return { value: zigZagDecode(value), bytesRead };\n}\nfunction zigZagEncode(value) {\n    return (value << 1n) ^ (value >> 63n);\n}\nfunction zigZagDecode(value) {\n    return (value >> 1n) ^ -(value & 1n);\n}\nexport class BinaryWriter {\n    chunks = [];\n    current = createBuffer();\n    writeByte(byte) {\n        pushByte(this.current, byte);\n    }\n    writeBytes(bytes) {\n        pushBytes(this.current, bytes);\n    }\n    writeBuffer(buffer) {\n        this.flushCurrent();\n        this.chunks.push(buffer.slice());\n        this.current = createBuffer();\n    }\n    writeUint8Array(arr) {\n        this.flushCurrent();\n        this.chunks.push(Array.from(arr));\n        this.current = createBuffer();\n    }\n    writeUvarint(value) {\n        writeUvarint(this.current, value);\n    }\n    toUint8Array() {\n        this.flushCurrent();\n        return concatByteBuffers(this.chunks);\n    }\n    reset() {\n        this.chunks.length = 0;\n        this.current = createBuffer();\n    }\n    flushCurrent() {\n        if (this.current.length > 0) {\n            this.chunks.push(this.current);\n            this.current = createBuffer();\n        }\n    }\n}\nexport class BinaryReader {\n    data;\n    offset;\n    constructor(data, offset = 0) {\n        this.data = data;\n        this.offset = offset;\n    }\n    ensure(size) {\n        if (this.offset + size > this.data.length) {\n            throw new RangeError(\"buffer underrun\");\n        }\n    }\n    readByte() {\n        this.ensure(1);\n        return this.data[this.offset++];\n    }\n    readBytes(length) {\n        this.ensure(length);\n        const slice = this.data.subarray(this.offset, this.offset + length);\n        this.offset += length;\n        return slice;\n    }\n    readUvarint() {\n        const { value, bytesRead } = readUvarint(this.data, this.offset);\n        this.offset += bytesRead;\n        return value;\n    }\n    readVarint() {\n        const { value, bytesRead } = readVarint(this.data, this.offset);\n        this.offset += bytesRead;\n        return value;\n    }\n    remaining() {\n        return this.data.length - this.offset;\n    }\n}\nexport function toSafeNumber(value, label) {\n    const v = Number(value);\n    if (!Number.isFinite(v) || v > Number.MAX_SAFE_INTEGER) {\n        throw new RangeError(`${label} exceeds safe number range`);\n    }\n    return v;\n}\nexport function encodeUint64LE(value) {\n    const v = BigInt(value);\n    const out = new Uint8Array(8);\n    let temp = v;\n    for (let i = 0; i < 8; i += 1) {\n        out[i] = Number(temp & 0xffn);\n        temp >>= 8n;\n    }\n    return out;\n}\n","import { pushByte, pushBytes, writeUvarint, writeVarint } from \"./binary\";\nconst encoder = new TextEncoder();\nexport class Uint64Column {\n    values = [];\n    append(value) {\n        this.values.push(BigInt(value));\n    }\n    encode(dst) {\n        const count = this.values.length;\n        const mode = count >= 2 && isMonotonic(this.values) ? 1n : 0n;\n        const header = (BigInt(count) << 1n) | mode;\n        writeUvarint(dst, header);\n        if (count === 0) {\n            return;\n        }\n        if (mode === 0n) {\n            for (const value of this.values) {\n                writeUvarint(dst, value);\n            }\n            return;\n        }\n        writeUvarint(dst, this.values[0]);\n        let prev = this.values[0];\n        for (let i = 1; i < count; i += 1) {\n            const delta = this.values[i] - prev;\n            writeUvarint(dst, delta);\n            prev = this.values[i];\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class Int64Column {\n    values = [];\n    append(value) {\n        this.values.push(BigInt(value));\n    }\n    encode(dst) {\n        const count = this.values.length;\n        const mode = count > 1 ? 1n : 0n;\n        const header = (BigInt(count) << 1n) | mode;\n        writeUvarint(dst, header);\n        if (count === 0) {\n            return;\n        }\n        if (mode === 0n) {\n            for (const value of this.values) {\n                writeVarint(dst, value);\n            }\n            return;\n        }\n        writeVarint(dst, this.values[0]);\n        let prev = this.values[0];\n        for (let i = 1; i < count; i += 1) {\n            const delta = this.values[i] - prev;\n            writeVarint(dst, delta);\n            prev = this.values[i];\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class Float64Column {\n    values = [];\n    append(value) {\n        this.values.push(value);\n    }\n    encode(dst) {\n        writeUvarint(dst, this.values.length);\n        for (const value of this.values) {\n            writeFloat64(dst, value);\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class BoolColumn {\n    values = [];\n    append(value) {\n        this.values.push(value ? 1 : 0);\n    }\n    encode(dst) {\n        writeUvarint(dst, this.values.length);\n        for (const value of this.values) {\n            pushByte(dst, value);\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nexport class StringColumn {\n    dict = new Map();\n    entries = [];\n    indexes = [];\n    append(value) {\n        if (!this.dict.has(value)) {\n            const bytes = encoder.encode(value);\n            this.dict.set(value, this.entries.length);\n            this.entries.push(bytes);\n        }\n        this.indexes.push(this.dict.get(value));\n    }\n    encode(dst) {\n        writeUvarint(dst, this.entries.length);\n        for (const entry of this.entries) {\n            writeUvarint(dst, entry.length);\n            pushBytes(dst, entry);\n        }\n        writeUvarint(dst, this.indexes.length);\n        for (const idx of this.indexes) {\n            writeUvarint(dst, BigInt(idx));\n        }\n    }\n    reset() {\n        this.dict.clear();\n        this.entries.length = 0;\n        this.indexes.length = 0;\n    }\n}\nexport class BytesColumn {\n    values = [];\n    append(value) {\n        const copy = new Uint8Array(value.length);\n        copy.set(value);\n        this.values.push(copy);\n    }\n    encode(dst) {\n        writeUvarint(dst, this.values.length);\n        for (const value of this.values) {\n            writeUvarint(dst, value.length);\n            pushBytes(dst, value);\n        }\n    }\n    reset() {\n        this.values.length = 0;\n    }\n}\nfunction isMonotonic(values) {\n    for (let i = 1; i < values.length; i += 1) {\n        if (values[i] < values[i - 1]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction writeFloat64(dst, value) {\n    const buffer = new ArrayBuffer(8);\n    const view = new DataView(buffer);\n    view.setFloat64(0, value, true);\n    for (let i = 0; i < 8; i += 1) {\n        pushByte(dst, view.getUint8(i));\n    }\n}\n","const ISO_DATE = /^(\\d{4})-(\\d{2})-(\\d{2})$/;\nconst ISO_DATE_TIME = /^(\\d{4})-(\\d{2})-(\\d{2})[ T](\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{1,9}))?)?$/;\nconst NUMERIC = /^[-+]?\\d+(?:\\.\\d+)?$/;\nconst DURATION_TOKEN = /(\\d+(?:\\.\\d+)?)(ns|us|µs|ms|s|m|h|d)/gi;\nconst NANOS = {\n    ns: 1n,\n    us: 1000n,\n    \"µs\": 1000n,\n    ms: 1000000n,\n    s: 1000000000n,\n    m: 60n * 1000000000n,\n    h: 60n * 60n * 1000000000n,\n    d: 24n * 60n * 60n * 1000000000n,\n};\nexport function parseDate(raw) {\n    const trimmed = raw.trim();\n    const iso = ISO_DATE.exec(trimmed);\n    if (!iso) {\n        const parsed = new Date(trimmed);\n        if (Number.isNaN(parsed.getTime())) {\n            throw new Error(`temporal: invalid date ${raw}`);\n        }\n        return utcDate(parsed.getUTCFullYear(), parsed.getUTCMonth(), parsed.getUTCDate());\n    }\n    const [, year, month, day] = iso;\n    return utcDate(Number(year), Number(month) - 1, Number(day));\n}\nexport function parseDateTime(raw) {\n    const trimmed = raw.trim();\n    const match = ISO_DATE_TIME.exec(trimmed);\n    if (!match) {\n        const parsed = new Date(trimmed);\n        if (Number.isNaN(parsed.getTime())) {\n            throw new Error(`temporal: invalid datetime ${raw}`);\n        }\n        return new Date(parsed.toISOString());\n    }\n    const [, y, m, d, hh, mm, ss = \"0\", frac = \"0\"] = match;\n    const nanos = normalizeFraction(frac);\n    const date = Date.UTC(Number(y), Number(m) - 1, Number(d), Number(hh), Number(mm), Number(ss));\n    return new Date(date + Number(nanos / 1000000n));\n}\nexport function parseTimestamp(raw) {\n    const trimmed = raw.trim();\n    if (NUMERIC.test(trimmed)) {\n        return numericTimestamp(trimmed);\n    }\n    const parsed = new Date(trimmed);\n    if (Number.isNaN(parsed.getTime())) {\n        return parseDateTime(trimmed);\n    }\n    return new Date(parsed.toISOString());\n}\nexport function parseTimestampTZ(raw) {\n    const trimmed = raw.trim();\n    if (NUMERIC.test(trimmed)) {\n        return numericTimestamp(trimmed);\n    }\n    const parsed = new Date(trimmed);\n    if (Number.isNaN(parsed.getTime())) {\n        throw new Error(`temporal: invalid timestamptz ${raw}`);\n    }\n    return parsed;\n}\nexport function parseDuration(raw) {\n    const trimmed = raw.trim();\n    if (!trimmed) {\n        throw new Error(\"temporal: empty duration\");\n    }\n    let total = 0n;\n    let matched = false;\n    for (const token of trimmed.matchAll(DURATION_TOKEN)) {\n        matched = true;\n        const [, value, unitRaw] = token;\n        const unit = unitRaw.toLowerCase();\n        const scale = NANOS[unit];\n        if (!scale) {\n            throw new Error(`temporal: unsupported duration unit ${unitRaw}`);\n        }\n        const [whole, frac = \"0\"] = value.split(\".\");\n        let nanos = BigInt(whole) * scale;\n        if (frac) {\n            const fracScale = scale / powerOfTen(frac.length);\n            nanos += BigInt(frac) * fracScale;\n        }\n        total += nanos;\n    }\n    if (!matched) {\n        throw new Error(`temporal: malformed duration ${raw}`);\n    }\n    return total;\n}\nexport function encodeInstant(value) {\n    if (value instanceof Date) {\n        return BigInt(value.getTime()) * 1000000n;\n    }\n    if (typeof value === \"number\") {\n        return BigInt(Math.trunc(value)) * 1000000n;\n    }\n    return value;\n}\nexport function encodeDate(value) {\n    if (value instanceof Date) {\n        const midnight = utcDate(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate());\n        return BigInt(midnight.getTime()) * 1000000n;\n    }\n    const parsed = parseDate(value);\n    return BigInt(parsed.getTime()) * 1000000n;\n}\nexport function formatTimestampTZ(value) {\n    return value.toISOString();\n}\nexport function canonicalTimestampTZ(raw) {\n    if (!raw.trim()) {\n        return \"\";\n    }\n    const parsed = parseTimestampTZ(raw);\n    return formatTimestampTZ(parsed);\n}\nexport function decodeInstant(value) {\n    const ns = BigInt(value);\n    if (ns === 0n) {\n        return new Date(0);\n    }\n    const ms = Number(ns / 1000000n);\n    return new Date(ms);\n}\nexport function decodeDate(value) {\n    return decodeInstant(value);\n}\nexport function formatDate(value) {\n    if (!Number.isFinite(value.getTime())) {\n        return \"\";\n    }\n    return value.toISOString().slice(0, 10);\n}\nexport function formatInstant(value) {\n    if (!Number.isFinite(value.getTime())) {\n        return \"\";\n    }\n    return value.toISOString();\n}\nexport function numericTimestamp(raw) {\n    if (raw.includes(\".\")) {\n        const [whole, frac] = raw.split(\".\");\n        const sec = BigInt(whole);\n        const fracDigits = BigInt(powerOfTen(frac.length));\n        const nanos = (BigInt(frac) * 1000000000n) / fracDigits;\n        return new Date(Number(sec * 1000n + nanos / 1000000n));\n    }\n    const value = BigInt(raw);\n    const nanos = inferEpochNanoseconds(value);\n    return new Date(Number(nanos / 1000000n));\n}\nexport function inferEpochNanoseconds(value) {\n    const abs = value < 0n ? -value : value;\n    if (abs < 100000000000n) {\n        return value * 1000000000n;\n    }\n    if (abs < 100000000000000n) {\n        return value * 1000000n;\n    }\n    if (abs < 100000000000000000n) {\n        return value * 1000n;\n    }\n    return value;\n}\nconst DURATION_UNITS = [\n    { nanos: 24n * 60n * 60n * 1000000000n, suffix: \"d\" },\n    { nanos: 60n * 60n * 1000000000n, suffix: \"h\" },\n    { nanos: 60n * 1000000000n, suffix: \"m\" },\n    { nanos: 1000000000n, suffix: \"s\" },\n    { nanos: 1000000n, suffix: \"ms\" },\n    { nanos: 1000n, suffix: \"µs\" },\n    { nanos: 1n, suffix: \"ns\" },\n];\nexport function formatDuration(nanos) {\n    if (nanos === 0n) {\n        return \"0s\";\n    }\n    const negative = nanos < 0n;\n    let remaining = negative ? -nanos : nanos;\n    const chunks = [];\n    for (const unit of DURATION_UNITS) {\n        if (remaining < unit.nanos) {\n            continue;\n        }\n        const value = remaining / unit.nanos;\n        remaining -= value * unit.nanos;\n        chunks.push(`${value}${unit.suffix}`);\n        if (remaining === 0n) {\n            break;\n        }\n    }\n    if (remaining > 0n) {\n        chunks.push(`${remaining}ns`);\n    }\n    return `${negative ? \"-\" : \"\"}${chunks.join(\"\")}`;\n}\nfunction utcDate(year, month, day) {\n    return new Date(Date.UTC(year, month, day, 0, 0, 0, 0));\n}\nfunction normalizeFraction(input) {\n    const digits = input.padEnd(9, \"0\").slice(0, 9);\n    return BigInt(digits);\n}\nfunction powerOfTen(exp) {\n    let result = 1n;\n    for (let i = 0; i < exp; i += 1) {\n        result *= 10n;\n    }\n    return result;\n}\n","import { encodeDate, encodeInstant, formatTimestampTZ, parseDate, parseDateTime, parseDuration, parseTimestamp, parseTimestampTZ } from \"./temporal\";\nconst FNV_OFFSET = 0xcbf29ce484222325n;\nconst FNV_PRIME = 0x100000001b3n;\nexport var FieldKind;\n(function (FieldKind) {\n    FieldKind[FieldKind[\"Invalid\"] = 0] = \"Invalid\";\n    FieldKind[FieldKind[\"Uint64\"] = 1] = \"Uint64\";\n    FieldKind[FieldKind[\"String\"] = 2] = \"String\";\n    FieldKind[FieldKind[\"Ref\"] = 3] = \"Ref\";\n    FieldKind[FieldKind[\"Bool\"] = 4] = \"Bool\";\n    FieldKind[FieldKind[\"Int64\"] = 5] = \"Int64\";\n    FieldKind[FieldKind[\"Float64\"] = 6] = \"Float64\";\n    FieldKind[FieldKind[\"Bytes\"] = 7] = \"Bytes\";\n    FieldKind[FieldKind[\"Date\"] = 8] = \"Date\";\n    FieldKind[FieldKind[\"DateTime\"] = 9] = \"DateTime\";\n    FieldKind[FieldKind[\"Timestamp\"] = 10] = \"Timestamp\";\n    FieldKind[FieldKind[\"TimestampTZ\"] = 11] = \"TimestampTZ\";\n    FieldKind[FieldKind[\"Duration\"] = 12] = \"Duration\";\n})(FieldKind || (FieldKind = {}));\nexport class DefaultValue {\n    kind;\n    boolValue;\n    intValue;\n    uintValue;\n    floatValue;\n    stringValue;\n    bytesValue;\n    constructor(kind, boolValue, intValue, uintValue, floatValue, stringValue, bytesValue) {\n        this.kind = kind;\n        this.boolValue = boolValue;\n        this.intValue = intValue;\n        this.uintValue = uintValue;\n        this.floatValue = floatValue;\n        this.stringValue = stringValue;\n        this.bytesValue = bytesValue;\n    }\n    hashKey() {\n        switch (this.kind) {\n            case FieldKind.Bool:\n                return `bool:${this.boolValue ? 1 : 0}`;\n            case FieldKind.Int64:\n                return `int:${this.intValue ?? 0n}`;\n            case FieldKind.Uint64:\n            case FieldKind.Ref:\n                return `uint:${this.uintValue ?? 0n}`;\n            case FieldKind.Float64:\n                return `float:${this.floatValue ?? 0}`;\n            case FieldKind.String:\n                return `string:${this.stringValue ?? \"\"}`;\n            case FieldKind.Bytes:\n                return `bytes:${bytesToBase64(this.bytesValue ?? new Uint8Array())}`;\n            case FieldKind.Date:\n            case FieldKind.DateTime:\n            case FieldKind.Timestamp:\n            case FieldKind.Duration:\n                return `int:${this.intValue ?? 0n}`;\n            case FieldKind.TimestampTZ:\n                return `timestamptz:${this.stringValue ?? \"\"}`;\n            default:\n                return \"\";\n        }\n    }\n}\nexport class Field {\n    name;\n    kind;\n    rawType;\n    targetSchema;\n    targetField;\n    autoIncrement;\n    attributes;\n    defaultValue;\n    resolvedKind = FieldKind.Invalid;\n    pendingDefault = \"\";\n    constructor(name, kind, rawType, targetSchema = \"\", targetField = \"\", autoIncrement = false, attributes = [], defaultValue) {\n        this.name = name;\n        this.kind = kind;\n        this.rawType = rawType;\n        this.targetSchema = targetSchema;\n        this.targetField = targetField;\n        this.autoIncrement = autoIncrement;\n        this.attributes = attributes;\n        this.defaultValue = defaultValue;\n    }\n    valueKind() {\n        if (this.kind === FieldKind.Ref) {\n            return this.resolvedKind === FieldKind.Invalid ? FieldKind.Uint64 : this.resolvedKind;\n        }\n        return this.resolvedKind === FieldKind.Invalid ? this.kind : this.resolvedKind;\n    }\n    isReference() {\n        return this.kind === FieldKind.Ref && !!this.targetSchema && !!this.targetField;\n    }\n}\nexport class Schema {\n    name;\n    fields;\n    fingerprintCache;\n    fieldIndex;\n    constructor(name, fields) {\n        this.name = name;\n        this.fields = fields;\n    }\n    fingerprint() {\n        if (this.fingerprintCache !== undefined) {\n            return this.fingerprintCache;\n        }\n        let hash = FNV_OFFSET;\n        const write = (str) => {\n            for (let i = 0; i < str.length; i += 1) {\n                hash ^= BigInt(str.charCodeAt(i));\n                hash = BigInt.asUintN(64, hash * FNV_PRIME);\n            }\n        };\n        write(this.name);\n        for (const field of this.fields) {\n            write(\"|\");\n            write(field.name);\n            write(\":\");\n            write(field.rawType);\n            if (field.targetSchema) {\n                write(\"->\");\n                write(`${field.targetSchema}.${field.targetField}`);\n            }\n            if (field.autoIncrement) {\n                write(\"+auto\");\n            }\n            if (field.attributes.length) {\n                const attrs = [...field.attributes].sort();\n                for (const attr of attrs) {\n                    write(`@${attr}`);\n                }\n            }\n            if (field.defaultValue) {\n                write(\"=def:\");\n                write(field.defaultValue.hashKey());\n            }\n        }\n        this.fingerprintCache = BigInt.asUintN(64, hash);\n        return this.fingerprintCache;\n    }\n    fieldIndexByName(name) {\n        if (!this.fieldIndex) {\n            this.fieldIndex = new Map();\n            this.fields.forEach((field, idx) => this.fieldIndex.set(field.name, idx));\n        }\n        const idx = this.fieldIndex.get(name);\n        if (idx === undefined) {\n            throw new Error(`scrt: field ${name} not found in schema ${this.name}`);\n        }\n        return idx;\n    }\n    tryFieldIndex(name) {\n        if (!this.fieldIndex) {\n            this.fieldIndex = new Map();\n            this.fields.forEach((field, idx) => this.fieldIndex.set(field.name, idx));\n        }\n        return this.fieldIndex.get(name);\n    }\n}\nexport class Document {\n    schemas;\n    data;\n    source;\n    constructor(schemas, data, source) {\n        this.schemas = schemas;\n        this.data = data;\n        this.source = source;\n    }\n    schema(name) {\n        return this.schemas.get(name);\n    }\n    records(name) {\n        return this.data.get(name);\n    }\n    finalize() {\n        for (const schema of this.schemas.values()) {\n            resolveSchemaKinds(this, schema);\n        }\n    }\n}\nexport function parseSchema(text) {\n    const lines = text.split(/\\r?\\n/).map((line) => line.trim());\n    const schemas = new Map();\n    const data = new Map();\n    let current;\n    let awaitingName = false;\n    let currentData = \"\";\n    const finishCurrent = () => {\n        if (!current) {\n            return;\n        }\n        if (schemas.has(current.name)) {\n            throw new Error(`scrt: duplicate schema ${current.name}`);\n        }\n        schemas.set(current.name, current);\n        current = undefined;\n    };\n    const startSchema = (name) => {\n        finishCurrent();\n        if (!name) {\n            throw new Error(\"scrt: schema name cannot be empty\");\n        }\n        current = new Schema(name, []);\n    };\n    for (const line of lines) {\n        if (!line) {\n            continue;\n        }\n        if (awaitingName) {\n            startSchema(line);\n            awaitingName = false;\n            continue;\n        }\n        if (line.startsWith(\"@schema\")) {\n            currentData = \"\";\n            let rest = line.slice(\"@schema\".length).trim();\n            if (rest.startsWith(\":\")) {\n                rest = rest.slice(1).trim();\n            }\n            if (!rest) {\n                awaitingName = true;\n                continue;\n            }\n            startSchema(rest);\n            continue;\n        }\n        if (line.startsWith(\"@field\")) {\n            currentData = \"\";\n            if (!current) {\n                throw new Error(\"scrt: @field outside schema block\");\n            }\n            const field = parseField(line.slice(\"@field\".length).trim());\n            current.fields.push(field);\n            continue;\n        }\n        if (line.startsWith(\"@\")) {\n            awaitingName = false;\n            finishCurrent();\n            if (line.includes(\"=\") && currentData) {\n                const sch = schemas.get(currentData);\n                if (sch) {\n                    const row = parseDataRow(line, sch);\n                    pushDataRow(data, currentData, row);\n                }\n                continue;\n            }\n            currentData = line.slice(1).trim();\n            continue;\n        }\n        if (currentData) {\n            const sch = schemas.get(currentData);\n            if (!sch) {\n                continue;\n            }\n            const row = parseDataRow(line, sch);\n            pushDataRow(data, currentData, row);\n            continue;\n        }\n    }\n    finishCurrent();\n    const doc = new Document(schemas, data);\n    doc.finalize();\n    return doc;\n}\nfunction pushDataRow(store, schemaName, row) {\n    if (!store.has(schemaName)) {\n        store.set(schemaName, []);\n    }\n    store.get(schemaName).push(row);\n}\nfunction parseField(body) {\n    const [name, typ, attrChunk] = splitFieldParts(body);\n    const { kind, targetSchema, targetField } = interpretFieldType(typ);\n    const field = new Field(name, kind, typ, targetSchema, targetField);\n    if (attrChunk) {\n        const attrs = splitFieldAttributes(attrChunk);\n        for (const attr of attrs) {\n            const lower = attr.toLowerCase();\n            switch (true) {\n                case lower === \"auto_increment\" || lower === \"autoincrement\" || lower === \"serial\":\n                    field.autoIncrement = true;\n                    break;\n                case lower.startsWith(\"default=\"):\n                case lower.startsWith(\"default:\"):\n                    assignFieldDefault(field, extractDefaultLiteral(attr));\n                    break;\n                default:\n                    break;\n            }\n            field.attributes.push(lower);\n        }\n    }\n    return field;\n}\nfunction splitFieldParts(body) {\n    const trimmed = body.trim();\n    const firstSep = trimmed.search(/[ \\t]/);\n    if (firstSep === -1) {\n        throw new Error(`scrt: invalid @field declaration ${body}`);\n    }\n    const name = trimmed.slice(0, firstSep).trim();\n    const rest = trimmed.slice(firstSep + 1).trim();\n    const secondSep = rest.search(/[ \\t]/);\n    if (secondSep === -1) {\n        return [name, rest, \"\"];\n    }\n    return [name, rest.slice(0, secondSep).trim(), rest.slice(secondSep + 1).trim()];\n}\nfunction interpretFieldType(raw) {\n    const typ = raw.toLowerCase();\n    switch (true) {\n        case typ === \"uint64\":\n            return { kind: FieldKind.Uint64, targetSchema: \"\", targetField: \"\" };\n        case typ === \"string\":\n            return { kind: FieldKind.String, targetSchema: \"\", targetField: \"\" };\n        case typ === \"bool\":\n            return { kind: FieldKind.Bool, targetSchema: \"\", targetField: \"\" };\n        case typ === \"int64\":\n            return { kind: FieldKind.Int64, targetSchema: \"\", targetField: \"\" };\n        case typ === \"float64\":\n            return { kind: FieldKind.Float64, targetSchema: \"\", targetField: \"\" };\n        case typ === \"bytes\":\n            return { kind: FieldKind.Bytes, targetSchema: \"\", targetField: \"\" };\n        case typ === \"date\":\n            return { kind: FieldKind.Date, targetSchema: \"\", targetField: \"\" };\n        case typ === \"datetime\":\n            return { kind: FieldKind.DateTime, targetSchema: \"\", targetField: \"\" };\n        case typ === \"timestamp\":\n            return { kind: FieldKind.Timestamp, targetSchema: \"\", targetField: \"\" };\n        case typ === \"timestamptz\":\n            return { kind: FieldKind.TimestampTZ, targetSchema: \"\", targetField: \"\" };\n        case typ === \"duration\":\n            return { kind: FieldKind.Duration, targetSchema: \"\", targetField: \"\" };\n        case typ.startsWith(\"ref:\"):\n            const [, schemaName, fieldName] = raw.split(\":\");\n            return { kind: FieldKind.Ref, targetSchema: schemaName ?? \"\", targetField: fieldName ?? \"\" };\n        default:\n            throw new Error(`scrt: unsupported field type ${raw}`);\n    }\n}\nfunction splitFieldAttributes(attrChunk) {\n    const attrs = [];\n    let current = \"\";\n    let quote = null;\n    for (const ch of attrChunk) {\n        if ((ch === '\"' || ch === \"'\" || ch === \"`\") && quote === null) {\n            quote = ch;\n            current += ch;\n        }\n        else if (quote && ch === quote) {\n            quote = null;\n            current += ch;\n        }\n        else if (!quote && ch === ',') {\n            if (current.trim()) {\n                attrs.push(current.trim());\n            }\n            current = \"\";\n        }\n        else {\n            current += ch;\n        }\n    }\n    if (current.trim()) {\n        attrs.push(current.trim());\n    }\n    return attrs;\n}\nfunction assignFieldDefault(field, literalRaw) {\n    const literal = literalRaw.trim();\n    if (!literal) {\n        return;\n    }\n    if (field.kind === FieldKind.Ref) {\n        field.pendingDefault = literal;\n        return;\n    }\n    field.defaultValue = parseDefaultLiteral(field.kind, literal);\n}\nfunction extractDefaultLiteral(attr) {\n    const sepIdx = attr.indexOf(\"=\") >= 0 ? attr.indexOf(\"=\") : attr.indexOf(\":\");\n    if (sepIdx === -1) {\n        return attr;\n    }\n    return attr.slice(sepIdx + 1);\n}\nfunction parseDefaultLiteral(kind, literal) {\n    switch (kind) {\n        case FieldKind.Bool:\n            return new DefaultValue(kind, literal.toLowerCase() === \"true\" || literal === \"1\");\n        case FieldKind.Int64:\n            return new DefaultValue(kind, undefined, BigInt(literal));\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            return new DefaultValue(kind, undefined, undefined, BigInt(literal));\n        case FieldKind.Float64:\n            return new DefaultValue(kind, undefined, undefined, undefined, Number(literal));\n        case FieldKind.String:\n            return new DefaultValue(kind, undefined, undefined, undefined, undefined, parseStringLiteral(literal));\n        case FieldKind.Bytes:\n            return new DefaultValue(kind, undefined, undefined, undefined, undefined, undefined, parseBytesLiteral(literal));\n        case FieldKind.Date:\n            return new DefaultValue(kind, undefined, encodeDate(parseDate(stripQuotes(literal))));\n        case FieldKind.DateTime:\n            return new DefaultValue(kind, undefined, encodeInstant(parseDateTime(stripQuotes(literal))));\n        case FieldKind.Timestamp:\n            return new DefaultValue(kind, undefined, encodeInstant(parseTimestamp(stripQuotes(literal))));\n        case FieldKind.TimestampTZ: {\n            const ts = parseTimestampTZ(stripQuotes(literal));\n            return new DefaultValue(kind, undefined, undefined, undefined, undefined, formatTimestampTZ(ts));\n        }\n        case FieldKind.Duration:\n            return new DefaultValue(kind, undefined, parseDuration(stripQuotes(literal)));\n        default:\n            throw new Error(`scrt: defaults not supported for kind ${kind}`);\n    }\n}\nfunction parseStringLiteral(raw) {\n    const trimmed = raw.trim();\n    if (!trimmed) {\n        return \"\";\n    }\n    if (trimmed.startsWith(\"\\\"\") || trimmed.startsWith(\"'\") || trimmed.startsWith(\"`\")) {\n        return trimmed.slice(1, -1);\n    }\n    return trimmed;\n}\nfunction stripQuotes(raw) {\n    const trimmed = raw.trim();\n    if (!trimmed) {\n        return \"\";\n    }\n    if ((trimmed.startsWith(\"\\\"\") && trimmed.endsWith(\"\\\"\")) || (trimmed.startsWith(\"'\") && trimmed.endsWith(\"'\")) || (trimmed.startsWith(\"`\") && trimmed.endsWith(\"`\"))) {\n        return trimmed.slice(1, -1);\n    }\n    return trimmed;\n}\nfunction parseBytesLiteral(raw) {\n    const trimmed = raw.trim();\n    if (trimmed.startsWith(\"0x\") || trimmed.startsWith(\"0X\")) {\n        const hex = trimmed.slice(2);\n        if (hex.length % 2 !== 0) {\n            throw new Error(`scrt: invalid hex literal ${raw}`);\n        }\n        const bytes = new Uint8Array(hex.length / 2);\n        for (let i = 0; i < hex.length; i += 2) {\n            bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);\n        }\n        return bytes;\n    }\n    return new TextEncoder().encode(stripQuotes(trimmed));\n}\nfunction parseDataRow(line, schema) {\n    const row = {};\n    const tokens = line.split(',');\n    let fieldIdx = 0;\n    let remaining = countValueTokens(tokens);\n    const skipAuto = () => {\n        while (fieldIdx < schema.fields.length && schema.fields[fieldIdx].autoIncrement) {\n            const nonAuto = countNonAuto(schema.fields, fieldIdx);\n            if (remaining > nonAuto) {\n                return;\n            }\n            fieldIdx += 1;\n        }\n    };\n    for (const token of tokens) {\n        const trimmed = token.trim();\n        if (!trimmed) {\n            fieldIdx += 1;\n            continue;\n        }\n        if (trimmed.startsWith(\"@\")) {\n            const { index, value } = applyExplicitAssignment(schema, trimmed.slice(1));\n            if (index >= 0) {\n                row[schema.fields[index].name] = value;\n                fieldIdx = Math.max(fieldIdx, index + 1);\n            }\n            continue;\n        }\n        skipAuto();\n        if (fieldIdx >= schema.fields.length) {\n            throw new Error(\"scrt: too many values in row\");\n        }\n        const field = schema.fields[fieldIdx];\n        row[field.name] = parseValue(trimmed, field);\n        fieldIdx += 1;\n        remaining -= 1;\n    }\n    return row;\n}\nfunction countValueTokens(tokens) {\n    return tokens.reduce((acc, token) => {\n        const trimmed = token.trim();\n        if (!trimmed || trimmed.startsWith(\"@\")) {\n            return acc;\n        }\n        return acc + 1;\n    }, 0);\n}\nfunction countNonAuto(fields, start) {\n    let count = 0;\n    for (let i = start; i < fields.length; i += 1) {\n        if (!fields[i].autoIncrement) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction applyExplicitAssignment(schema, expr) {\n    const [fieldToken, rawValue] = expr.split(\"=\", 2);\n    if (!rawValue) {\n        throw new Error(`scrt: invalid assignment ${expr}`);\n    }\n    const normalized = normalizeAssignmentTarget(fieldToken);\n    const idx = schema.tryFieldIndex(normalized);\n    if (idx === undefined) {\n        throw new Error(`scrt: field ${normalized} not found`);\n    }\n    const field = schema.fields[idx];\n    return { index: idx, value: parseValue(rawValue.trim(), field) };\n}\nfunction normalizeAssignmentTarget(token) {\n    const trimmed = token.trim();\n    const parts = trimmed.split(\":\");\n    if (parts.length >= 2) {\n        return parts[1];\n    }\n    return parts[0];\n}\nfunction parseValue(raw, field) {\n    const kind = field.valueKind();\n    const trimmed = raw.trim();\n    switch (kind) {\n        case FieldKind.Uint64:\n            return BigInt(trimmed);\n        case FieldKind.Int64:\n            return BigInt(trimmed);\n        case FieldKind.Float64:\n            return Number(trimmed);\n        case FieldKind.Bool:\n            return trimmed.toLowerCase() === \"true\" || trimmed === \"1\";\n        case FieldKind.String:\n            return stripQuotes(trimmed);\n        case FieldKind.Bytes:\n            return parseBytesLiteral(trimmed);\n        case FieldKind.Date:\n            return parseDate(stripQuotes(trimmed));\n        case FieldKind.DateTime:\n            return parseDateTime(stripQuotes(trimmed));\n        case FieldKind.Timestamp:\n            return parseTimestamp(stripQuotes(trimmed));\n        case FieldKind.TimestampTZ:\n            return parseTimestampTZ(stripQuotes(trimmed));\n        case FieldKind.Duration:\n            return parseDuration(stripQuotes(trimmed));\n        default:\n            return trimmed;\n    }\n}\nfunction resolveSchemaKinds(doc, schema) {\n    schema.fields.forEach((field, idx) => resolveFieldKind(doc, schema, idx, new Set()));\n}\nfunction resolveFieldKind(doc, schema, idx, stack) {\n    const field = schema.fields[idx];\n    if (field.resolvedKind !== FieldKind.Invalid) {\n        return field.resolvedKind;\n    }\n    if (field.kind !== FieldKind.Ref) {\n        field.resolvedKind = field.kind;\n        if (field.pendingDefault && !field.defaultValue) {\n            field.defaultValue = parseDefaultLiteral(field.resolvedKind, field.pendingDefault);\n            field.pendingDefault = \"\";\n        }\n        return field.resolvedKind;\n    }\n    const key = `${schema.name}.${field.name}`;\n    if (stack.has(key)) {\n        throw new Error(`scrt: circular reference detected for ${key}`);\n    }\n    stack.add(key);\n    const targetSchema = doc.schemas.get(field.targetSchema);\n    if (!targetSchema) {\n        throw new Error(`scrt: schema ${schema.name} references unknown schema ${field.targetSchema}`);\n    }\n    const targetIdx = targetSchema.tryFieldIndex(field.targetField);\n    if (targetIdx === undefined) {\n        throw new Error(`scrt: schema ${schema.name} references unknown field ${field.targetSchema}.${field.targetField}`);\n    }\n    const resolved = resolveFieldKind(doc, targetSchema, targetIdx, stack);\n    field.resolvedKind = resolved;\n    stack.delete(key);\n    if (field.pendingDefault && !field.defaultValue) {\n        field.defaultValue = parseDefaultLiteral(resolved, field.pendingDefault);\n        field.pendingDefault = \"\";\n    }\n    return resolved;\n}\nfunction bytesToBase64(bytes) {\n    if (typeof Buffer !== \"undefined\") {\n        return Buffer.from(bytes).toString(\"base64\");\n    }\n    let binary = \"\";\n    for (let i = 0; i < bytes.length; i += 1) {\n        binary += String.fromCharCode(bytes[i]);\n    }\n    if (typeof btoa === \"function\") {\n        return btoa(binary);\n    }\n    throw new Error(\"scrt: base64 encoding unavailable in this environment\");\n}\n","import { createBuffer, pushByte, pushBytes, writeUvarint } from \"./binary\";\nimport { BoolColumn, BytesColumn, Float64Column, Int64Column, StringColumn, Uint64Column } from \"./column\";\nimport { FieldKind } from \"./schema\";\nexport class PageBuilder {\n    schema;\n    rowLimit;\n    columns;\n    columnBuf = createBuffer();\n    rows = 0;\n    constructor(schema, rowLimit = 1024) {\n        this.schema = schema;\n        this.rowLimit = rowLimit;\n        this.columns = schema.fields.map((field) => {\n            const kind = field.valueKind();\n            const handle = { kind, presence: [] };\n            switch (kind) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    handle.uints = new Uint64Column();\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    handle.strings = new StringColumn();\n                    break;\n                case FieldKind.Bool:\n                    handle.bools = new BoolColumn();\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    handle.ints = new Int64Column();\n                    break;\n                case FieldKind.Float64:\n                    handle.floats = new Float64Column();\n                    break;\n                case FieldKind.Bytes:\n                    handle.bytes = new BytesColumn();\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${kind}`);\n            }\n            return handle;\n        });\n    }\n    appendUint(idx, value) {\n        this.columns[idx].uints?.append(value);\n    }\n    appendString(idx, value) {\n        this.columns[idx].strings?.append(value);\n    }\n    appendBool(idx, value) {\n        this.columns[idx].bools?.append(value);\n    }\n    appendInt(idx, value) {\n        this.columns[idx].ints?.append(value);\n    }\n    appendFloat(idx, value) {\n        this.columns[idx].floats?.append(value);\n    }\n    appendBytes(idx, value) {\n        this.columns[idx].bytes?.append(value);\n    }\n    recordPresence(idx, present) {\n        this.columns[idx].presence.push(present);\n    }\n    sealRow() {\n        this.rows += 1;\n        if (this.rows > this.rowLimit) {\n            throw new Error(\"scrt: page builder capacity exceeded\");\n        }\n    }\n    full() {\n        return this.rows >= this.rowLimit;\n    }\n    rowCount() {\n        return this.rows;\n    }\n    reset() {\n        this.rows = 0;\n        for (const column of this.columns) {\n            column.presence.length = 0;\n            column.uints?.reset();\n            column.strings?.reset();\n            column.bools?.reset();\n            column.ints?.reset();\n            column.floats?.reset();\n            column.bytes?.reset();\n        }\n    }\n    encode(dst) {\n        if (this.rows === 0) {\n            return;\n        }\n        writeUvarint(dst, this.rows);\n        writeUvarint(dst, this.columns.length);\n        for (let idx = 0; idx < this.columns.length; idx += 1) {\n            const column = this.columns[idx];\n            this.columnBuf.length = 0;\n            writePresence(this.columnBuf, column.presence, this.rows);\n            switch (column.kind) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    column.uints?.encode(this.columnBuf);\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    column.strings?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Bool:\n                    column.bools?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    column.ints?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Float64:\n                    column.floats?.encode(this.columnBuf);\n                    break;\n                case FieldKind.Bytes:\n                    column.bytes?.encode(this.columnBuf);\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${column.kind}`);\n            }\n            writeUvarint(dst, idx);\n            pushByte(dst, column.kind);\n            writeUvarint(dst, this.columnBuf.length);\n            pushBytes(dst, this.columnBuf);\n        }\n    }\n}\nfunction writePresence(dst, presence, rows) {\n    const byteLen = Math.floor((rows + 7) / 8);\n    writeUvarint(dst, byteLen);\n    if (byteLen === 0) {\n        return;\n    }\n    let current = 0;\n    let shift = 0;\n    let written = 0;\n    for (let row = 0; row < rows; row += 1) {\n        if (presence[row]) {\n            current |= 1 << shift;\n        }\n        shift += 1;\n        if (shift === 8) {\n            pushByte(dst, current);\n            written += 1;\n            current = 0;\n            shift = 0;\n        }\n    }\n    if (shift !== 0) {\n        pushByte(dst, current);\n        written += 1;\n    }\n    while (written < byteLen) {\n        pushByte(dst, 0);\n        written += 1;\n    }\n}\n","import { bufferToUint8Array, createBuffer, pushBytes, writeUvarint } from \"./binary\";\nimport { PageBuilder } from \"./page\";\nimport { FieldKind } from \"./schema\";\nimport { readUvarint, readVarint } from \"./binary\";\nconst MAGIC = \"SCRT\";\nconst VERSION = 2;\nconst textDecoder = new TextDecoder();\nexport class Row {\n    schema;\n    values;\n    constructor(schema) {\n        this.schema = schema;\n        this.values = new Array(schema.fields.length).fill(null).map(() => ({ set: false }));\n    }\n    reset() {\n        for (const value of this.values) {\n            value.set = false;\n            value.uint = undefined;\n            value.int = undefined;\n            value.float = undefined;\n            value.str = undefined;\n            value.bytes = undefined;\n            value.bool = undefined;\n            value.borrowed = undefined;\n        }\n    }\n    setByIndex(idx, value) {\n        this.values[idx] = { ...value, set: true };\n    }\n    valuesSlice() {\n        return this.values;\n    }\n    fieldIndex(name) {\n        return this.schema.fieldIndexByName(name);\n    }\n    setValue(field, value) {\n        this.setByIndex(this.fieldIndex(field), value);\n    }\n    setUint(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.uint = BigInt(value);\n    }\n    setInt(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.int = BigInt(value);\n    }\n    setFloat(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.float = value;\n    }\n    setBool(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.bool = value;\n    }\n    setString(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.str = value;\n    }\n    setBytes(field, value) {\n        const slot = this.claimSlot(this.fieldIndex(field));\n        slot.bytes = cloneBytes(value);\n    }\n    claimSlot(idx) {\n        const slot = this.values[idx];\n        slot.set = true;\n        slot.uint = undefined;\n        slot.int = undefined;\n        slot.float = undefined;\n        slot.str = undefined;\n        slot.bytes = undefined;\n        slot.bool = undefined;\n        slot.borrowed = false;\n        return slot;\n    }\n}\nexport class Writer {\n    schema;\n    builder;\n    output = createBuffer();\n    headerWritten = false;\n    constructor(schema, rowsPerPage = 1024) {\n        this.schema = schema;\n        this.builder = new PageBuilder(schema, rowsPerPage);\n    }\n    writeRow(row) {\n        if (row.schema !== this.schema) {\n            throw new Error(\"scrt: schema mismatch for row\");\n        }\n        this.ensureHeader();\n        const values = row.valuesSlice();\n        this.schema.fields.forEach((field, idx) => {\n            const value = values[idx];\n            if (!value.set) {\n                this.builder.recordPresence(idx, false);\n                return;\n            }\n            this.builder.recordPresence(idx, true);\n            switch (field.valueKind()) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    this.builder.appendUint(idx, value.uint ?? 0n);\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    this.builder.appendString(idx, value.str ?? \"\");\n                    break;\n                case FieldKind.Bool:\n                    this.builder.appendBool(idx, value.bool ?? false);\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    this.builder.appendInt(idx, value.int ?? 0n);\n                    break;\n                case FieldKind.Float64:\n                    this.builder.appendFloat(idx, value.float ?? 0);\n                    break;\n                case FieldKind.Bytes:\n                    this.builder.appendBytes(idx, value.bytes ?? new Uint8Array());\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${field.valueKind()}`);\n            }\n        });\n        this.builder.sealRow();\n        if (this.builder.full()) {\n            this.flushPage();\n        }\n    }\n    finish() {\n        this.flushPage();\n        return bufferToUint8Array(this.output);\n    }\n    ensureHeader() {\n        if (this.headerWritten) {\n            return;\n        }\n        for (const ch of MAGIC) {\n            this.output.push(ch.charCodeAt(0));\n        }\n        this.output.push(VERSION);\n        const fp = this.schema.fingerprint();\n        const header = new Uint8Array(8);\n        let temp = fp;\n        for (let i = 0; i < 8; i += 1) {\n            header[i] = Number(temp & 0xffn);\n            temp >>= 8n;\n        }\n        pushBytes(this.output, header);\n        this.headerWritten = true;\n    }\n    flushPage() {\n        if (this.builder.rowCount() === 0) {\n            return;\n        }\n        const pageBuf = createBuffer();\n        this.builder.encode(pageBuf);\n        const lenBuf = createBuffer();\n        writeUvarint(lenBuf, pageBuf.length);\n        pushBytes(this.output, lenBuf);\n        pushBytes(this.output, pageBuf);\n        this.builder.reset();\n    }\n}\nclass DecodedPage {\n    rows = 0;\n    cursor = 0;\n    columns;\n    constructor(fieldCount) {\n        this.columns = new Array(fieldCount).fill(null).map(() => ({\n            kind: FieldKind.Invalid,\n            rowIndexes: [],\n            uints: [],\n            stringTable: [],\n            stringIndexes: [],\n            bools: [],\n            ints: [],\n            floats: [],\n            bytes: [],\n        }));\n    }\n}\nexport class Reader {\n    data;\n    schema;\n    options;\n    state;\n    offset = 0;\n    headerRead = false;\n    constructor(data, schema, options = {}) {\n        this.data = data;\n        this.schema = schema;\n        this.options = options;\n        this.state = new DecodedPage(schema.fields.length);\n    }\n    readRow(row) {\n        if (!this.headerRead && !this.consumeHeader()) {\n            return false;\n        }\n        if (this.state.cursor >= this.state.rows) {\n            if (!this.loadPage()) {\n                return false;\n            }\n        }\n        const rowIdx = this.state.cursor;\n        const values = row.valuesSlice();\n        for (let fieldIdx = 0; fieldIdx < this.schema.fields.length; fieldIdx += 1) {\n            const field = this.schema.fields[fieldIdx];\n            const column = this.state.columns[fieldIdx];\n            const valueSlot = values[fieldIdx];\n            const valueIdx = column.rowIndexes[rowIdx] ?? -1;\n            if (valueIdx < 0) {\n                assignDefaultValue(field, valueSlot);\n                continue;\n            }\n            valueSlot.set = true;\n            switch (field.valueKind()) {\n                case FieldKind.Uint64:\n                case FieldKind.Ref:\n                    valueSlot.uint = column.uints[valueIdx];\n                    break;\n                case FieldKind.String:\n                case FieldKind.TimestampTZ:\n                    valueSlot.str = column.stringTable[column.stringIndexes[valueIdx] ?? 0] ?? \"\";\n                    break;\n                case FieldKind.Bool:\n                    valueSlot.bool = column.bools[valueIdx];\n                    break;\n                case FieldKind.Int64:\n                case FieldKind.Date:\n                case FieldKind.DateTime:\n                case FieldKind.Timestamp:\n                case FieldKind.Duration:\n                    valueSlot.int = column.ints[valueIdx];\n                    break;\n                case FieldKind.Float64:\n                    valueSlot.float = column.floats[valueIdx];\n                    break;\n                case FieldKind.Bytes:\n                    valueSlot.bytes = column.bytes[valueIdx];\n                    valueSlot.borrowed = this.options.zeroCopyBytes ?? false;\n                    break;\n                default:\n                    throw new Error(`scrt: unsupported field kind ${field.valueKind()}`);\n            }\n        }\n        this.state.cursor += 1;\n        return true;\n    }\n    consumeHeader() {\n        if (this.data.length < MAGIC.length + 1 + 8) {\n            return false;\n        }\n        const magic = textDecoder.decode(this.data.subarray(0, MAGIC.length));\n        if (magic !== MAGIC) {\n            throw new Error(\"scrt: invalid stream header\");\n        }\n        const version = this.data[MAGIC.length];\n        if (version !== VERSION) {\n            throw new Error(`scrt: unsupported version ${version}`);\n        }\n        const fpBytes = this.data.subarray(MAGIC.length + 1, MAGIC.length + 9);\n        let fp = 0n;\n        for (let i = 7; i >= 0; i -= 1) {\n            fp = (fp << 8n) | BigInt(fpBytes[i]);\n        }\n        if (fp !== this.schema.fingerprint()) {\n            throw new Error(\"scrt: schema fingerprint mismatch\");\n        }\n        this.offset = MAGIC.length + 9;\n        this.headerRead = true;\n        return true;\n    }\n    loadPage() {\n        if (this.offset >= this.data.length) {\n            return false;\n        }\n        const { value: length, bytesRead } = readUvarint(this.data, this.offset);\n        this.offset += bytesRead;\n        const pageLength = Number(length);\n        if (pageLength === 0 || this.offset + pageLength > this.data.length) {\n            return false;\n        }\n        const raw = this.data.subarray(this.offset, this.offset + pageLength);\n        this.offset += pageLength;\n        this.decodePage(raw);\n        return true;\n    }\n    decodePage(raw) {\n        let cursor = 0;\n        const { value: rows, bytesRead: rowsRead } = readUvarint(raw, cursor);\n        cursor += rowsRead;\n        const rowCount = Number(rows);\n        const { value: columns, bytesRead: columnsRead } = readUvarint(raw, cursor);\n        cursor += columnsRead;\n        const columnCount = Number(columns);\n        if (columnCount !== this.schema.fields.length) {\n            throw new Error(\"scrt: column count mismatch\");\n        }\n        this.state.rows = rowCount;\n        this.state.cursor = 0;\n        for (let i = 0; i < columnCount; i += 1) {\n            const { value: fieldIdxBig, bytesRead: fieldIdxRead } = readUvarint(raw, cursor);\n            cursor += fieldIdxRead;\n            const fieldIdx = Number(fieldIdxBig);\n            const kind = raw[cursor];\n            cursor += 1;\n            const { value: payloadLen, bytesRead: payloadLenRead } = readUvarint(raw, cursor);\n            cursor += payloadLenRead;\n            const payload = raw.subarray(cursor, cursor + Number(payloadLen));\n            cursor += Number(payloadLen);\n            this.decodeColumn(fieldIdx, kind, payload, rowCount);\n        }\n    }\n    decodeColumn(idx, kind, payload, rows) {\n        const column = this.state.columns[idx];\n        column.kind = kind;\n        const presence = decodePresence(payload, rows);\n        column.rowIndexes = presence.indexes;\n        const buffer = payload.subarray(presence.bytesRead);\n        switch (kind) {\n            case FieldKind.Uint64:\n            case FieldKind.Ref: {\n                const decoded = decodeUintColumn(buffer, presence.setCount);\n                column.uints = decoded.values;\n                break;\n            }\n            case FieldKind.String:\n            case FieldKind.TimestampTZ: {\n                const decoded = decodeStringColumn(buffer, presence.setCount);\n                column.stringTable = decoded.table;\n                column.stringIndexes = decoded.indexes;\n                break;\n            }\n            case FieldKind.Bool: {\n                const decoded = decodeBoolColumn(buffer, presence.setCount);\n                column.bools = decoded.values;\n                break;\n            }\n            case FieldKind.Int64:\n            case FieldKind.Date:\n            case FieldKind.DateTime:\n            case FieldKind.Timestamp:\n            case FieldKind.Duration: {\n                const decoded = decodeIntColumn(buffer, presence.setCount);\n                column.ints = decoded.values;\n                break;\n            }\n            case FieldKind.Float64: {\n                const decoded = decodeFloatColumn(buffer, presence.setCount);\n                column.floats = decoded.values;\n                break;\n            }\n            case FieldKind.Bytes: {\n                const decoded = decodeBytesColumn(buffer, presence.setCount, this.options.zeroCopyBytes ?? false);\n                column.bytes = decoded.values;\n                break;\n            }\n            default:\n                throw new Error(`scrt: unsupported field kind ${kind}`);\n        }\n    }\n}\nfunction decodePresence(data, rows) {\n    const { value: byteLenBig, bytesRead } = readUvarint(data, 0);\n    const byteLen = Number(byteLenBig);\n    let cursor = bytesRead;\n    const indexes = new Array(rows).fill(-1);\n    let setCount = 0;\n    for (let row = 0; row < rows; row += 1) {\n        const byteIdx = Math.floor(row / 8);\n        const bit = row % 8;\n        if (byteIdx < byteLen) {\n            const present = (data[cursor + byteIdx] & (1 << bit)) !== 0;\n            if (present) {\n                indexes[row] = setCount;\n                setCount += 1;\n            }\n        }\n    }\n    cursor += byteLen;\n    return { indexes, setCount, bytesRead: cursor };\n}\nfunction decodeUintColumn(data, expected) {\n    let cursor = 0;\n    const { value: header, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const mode = header & 1n;\n    const count = Number(header >> 1n);\n    if (count !== expected) {\n        throw new Error(\"scrt: uint column count mismatch\");\n    }\n    const values = new Array(count).fill(0n);\n    if (count === 0) {\n        return { values };\n    }\n    if (mode === 0n) {\n        for (let i = 0; i < count; i += 1) {\n            const result = readUvarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = result.value;\n        }\n    }\n    else {\n        let result = readUvarint(data, cursor);\n        cursor += result.bytesRead;\n        values[0] = result.value;\n        for (let i = 1; i < count; i += 1) {\n            result = readUvarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = values[i - 1] + result.value;\n        }\n    }\n    return { values };\n}\nfunction decodeIntColumn(data, expected) {\n    let cursor = 0;\n    const { value: header, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const mode = header & 1n;\n    const count = Number(header >> 1n);\n    if (count !== expected) {\n        throw new Error(\"scrt: int column count mismatch\");\n    }\n    const values = new Array(count).fill(0n);\n    if (count === 0) {\n        return { values };\n    }\n    if (mode === 0n) {\n        for (let i = 0; i < count; i += 1) {\n            const result = readVarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = result.value;\n        }\n    }\n    else {\n        let result = readVarint(data, cursor);\n        cursor += result.bytesRead;\n        values[0] = result.value;\n        for (let i = 1; i < count; i += 1) {\n            result = readVarint(data, cursor);\n            cursor += result.bytesRead;\n            values[i] = values[i - 1] + result.value;\n        }\n    }\n    return { values };\n}\nfunction decodeFloatColumn(data, expected) {\n    let cursor = 0;\n    const { value: countBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const count = Number(countBig);\n    if (count !== expected) {\n        throw new Error(\"scrt: float column count mismatch\");\n    }\n    const values = new Array(count).fill(0);\n    const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    for (let i = 0; i < count; i += 1) {\n        if (cursor + 8 > data.length) {\n            throw new Error(\"scrt: float column truncated\");\n        }\n        values[i] = view.getFloat64(cursor, true);\n        cursor += 8;\n    }\n    return { values };\n}\nfunction decodeBoolColumn(data, expected) {\n    let cursor = 0;\n    const { value: countBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const count = Number(countBig);\n    if (count !== expected) {\n        throw new Error(\"scrt: bool column count mismatch\");\n    }\n    const values = new Array(count);\n    for (let i = 0; i < count; i += 1) {\n        values[i] = data[cursor + i] !== 0;\n    }\n    return { values };\n}\nfunction decodeStringColumn(data, expected) {\n    let cursor = 0;\n    const { value: dictLenBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const dictLen = Number(dictLenBig);\n    const table = new Array(dictLen);\n    for (let i = 0; i < dictLen; i += 1) {\n        const lengthInfo = readUvarint(data, cursor);\n        cursor += lengthInfo.bytesRead;\n        const length = Number(lengthInfo.value);\n        const slice = data.subarray(cursor, cursor + length);\n        table[i] = textDecoder.decode(slice);\n        cursor += length;\n    }\n    const { value: indexLenBig, bytesRead: indexRead } = readUvarint(data, cursor);\n    cursor += indexRead;\n    const indexLen = Number(indexLenBig);\n    if (indexLen !== expected) {\n        throw new Error(\"scrt: string index count mismatch\");\n    }\n    const indexes = new Array(indexLen);\n    for (let i = 0; i < indexLen; i += 1) {\n        const idxInfo = readUvarint(data, cursor);\n        cursor += idxInfo.bytesRead;\n        indexes[i] = Number(idxInfo.value);\n    }\n    return { table, indexes };\n}\nfunction decodeBytesColumn(data, expected, zeroCopy) {\n    let cursor = 0;\n    const { value: countBig, bytesRead } = readUvarint(data, cursor);\n    cursor += bytesRead;\n    const count = Number(countBig);\n    if (count !== expected) {\n        throw new Error(\"scrt: bytes column count mismatch\");\n    }\n    const values = new Array(count);\n    for (let i = 0; i < count; i += 1) {\n        const lengthInfo = readUvarint(data, cursor);\n        cursor += lengthInfo.bytesRead;\n        const length = Number(lengthInfo.value);\n        const slice = data.subarray(cursor, cursor + length);\n        values[i] = zeroCopy ? slice : cloneBytes(slice);\n        cursor += length;\n    }\n    return { values };\n}\nfunction cloneBytes(src) {\n    const copy = new Uint8Array(src.length);\n    copy.set(src);\n    return copy;\n}\nfunction assignDefaultValue(field, slot) {\n    slot.set = false;\n    const def = field.defaultValue;\n    if (!def) {\n        return;\n    }\n    slot.set = true;\n    switch (def.kind) {\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            slot.uint = def.uintValue ?? 0n;\n            break;\n        case FieldKind.Int64:\n        case FieldKind.Date:\n        case FieldKind.DateTime:\n        case FieldKind.Timestamp:\n        case FieldKind.Duration:\n            slot.int = def.intValue ?? 0n;\n            break;\n        case FieldKind.Float64:\n            slot.float = def.floatValue ?? 0;\n            break;\n        case FieldKind.Bool:\n            slot.bool = def.boolValue ?? false;\n            break;\n        case FieldKind.String:\n        case FieldKind.TimestampTZ:\n            slot.str = def.stringValue ?? \"\";\n            break;\n        case FieldKind.Bytes:\n            slot.bytes = def.bytesValue ? cloneBytes(def.bytesValue) : new Uint8Array();\n            break;\n        default:\n            slot.set = false;\n    }\n}\n","import { Reader, Row, Writer } from \"./codec\";\nimport { FieldKind } from \"./schema\";\nimport { canonicalTimestampTZ, decodeDate, decodeInstant, encodeDate, encodeInstant, formatDate, formatDuration, formatInstant, formatTimestampTZ, inferEpochNanoseconds, parseDate, parseDateTime, parseDuration, parseTimestamp, parseTimestampTZ, } from \"./temporal\";\nconst textEncoder = new TextEncoder();\nconst textDecoder = new TextDecoder();\nexport function marshalRecords(schema, source, options = {}) {\n    if (!schema) {\n        throw new Error(\"scrt: schema is required for marshal\");\n    }\n    const writer = new Writer(schema, options.rowsPerPage ?? 1024);\n    const scratch = new Row(schema);\n    for (const record of toIterable(source)) {\n        if (record instanceof Row) {\n            if (record.schema !== schema) {\n                throw new Error(\"scrt: row schema mismatch during marshal\");\n            }\n            writer.writeRow(record);\n            continue;\n        }\n        if (!isRecordShape(record)) {\n            throw new Error(\"scrt: marshal expects plain objects, maps, or Row instances\");\n        }\n        populateRow(scratch, schema, record);\n        writer.writeRow(scratch);\n    }\n    return writer.finish();\n}\nexport function unmarshalRecords(source, schema, options) {\n    const results = [];\n    for (const record of streamDecodedRows(source, schema, options)) {\n        results.push(record);\n    }\n    return results;\n}\nexport function* streamDecodedRows(source, schema, options) {\n    if (!schema) {\n        throw new Error(\"scrt: schema is required for unmarshal\");\n    }\n    const resolved = resolveUnmarshalOptions(options);\n    const reader = new Reader(normalizeBinarySource(source), schema, { zeroCopyBytes: resolved.zeroCopyBytes });\n    const row = new Row(schema);\n    while (reader.readRow(row)) {\n        const materialized = materializeRow(row, schema, resolved);\n        yield materialized;\n        row.reset();\n    }\n}\nfunction toIterable(source) {\n    if (isIterable(source)) {\n        return source;\n    }\n    return [source];\n}\nfunction isIterable(value) {\n    if (value == null) {\n        return false;\n    }\n    if (typeof value === \"string\") {\n        return false;\n    }\n    const candidate = value;\n    return typeof candidate[Symbol.iterator] === \"function\";\n}\nfunction isRecordShape(value) {\n    if (value instanceof Map) {\n        return true;\n    }\n    if (value instanceof Date) {\n        return false;\n    }\n    if (value && typeof value === \"object\") {\n        if (Array.isArray(value)) {\n            return false;\n        }\n        if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction populateRow(row, schema, record) {\n    row.reset();\n    const accessor = createAccessor(record);\n    schema.fields.forEach((field, idx) => {\n        const raw = accessor(field.name);\n        if (raw === undefined || raw === null) {\n            return;\n        }\n        const encoded = encodeFieldValue(field, raw);\n        if (encoded) {\n            row.setByIndex(idx, encoded);\n        }\n    });\n}\nfunction createAccessor(record) {\n    if (record instanceof Map) {\n        return (field) => record.get(field);\n    }\n    return (field) => record[field];\n}\nfunction encodeFieldValue(field, raw) {\n    if (raw === undefined || raw === null) {\n        return null;\n    }\n    const kind = field.valueKind();\n    const slot = { set: true };\n    switch (kind) {\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            slot.uint = coerceUint(raw, field.name);\n            return slot;\n        case FieldKind.Int64:\n            slot.int = coerceInt(raw, field.name);\n            return slot;\n        case FieldKind.Float64:\n            slot.float = coerceFloat(raw, field.name);\n            return slot;\n        case FieldKind.Bool:\n            slot.bool = coerceBool(raw, field.name);\n            return slot;\n        case FieldKind.String:\n            slot.str = coerceString(raw, field.name);\n            return slot;\n        case FieldKind.Bytes:\n            slot.bytes = coerceBytes(raw, field.name);\n            return slot;\n        case FieldKind.Date:\n            slot.int = encodeDate(coerceDate(raw, field.name, FieldKind.Date));\n            return slot;\n        case FieldKind.DateTime:\n        case FieldKind.Timestamp:\n            slot.int = encodeInstant(coerceDate(raw, field.name, kind));\n            return slot;\n        case FieldKind.TimestampTZ:\n            slot.str = coerceTimestampTZ(raw, field.name);\n            return slot;\n        case FieldKind.Duration:\n            slot.int = coerceDuration(raw, field.name);\n            return slot;\n        default:\n            throw new Error(`scrt: unsupported field kind ${kind} for ${field.name}`);\n    }\n}\nfunction coerceUint(value, label) {\n    const result = coerceInt(value, label);\n    if (result < 0n) {\n        throw new Error(`scrt: ${label} cannot be negative`);\n    }\n    return result;\n}\nfunction coerceInt(value, label) {\n    if (typeof value === \"bigint\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value) || !Number.isInteger(value)) {\n            throw new Error(`scrt: ${label} must be a finite integer`);\n        }\n        if (Math.abs(value) > Number.MAX_SAFE_INTEGER) {\n            throw new Error(`scrt: ${label} exceeds safe integer range`);\n        }\n        return BigInt(value);\n    }\n    if (typeof value === \"string\") {\n        const trimmed = value.trim();\n        if (!trimmed) {\n            throw new Error(`scrt: ${label} cannot be empty`);\n        }\n        return BigInt(trimmed);\n    }\n    throw new Error(`scrt: ${label} expects an integer-compatible value`);\n}\nfunction coerceFloat(value, label) {\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return value;\n    }\n    if (typeof value === \"bigint\") {\n        return Number(value);\n    }\n    if (typeof value === \"string\") {\n        const parsed = Number(value.trim());\n        if (Number.isNaN(parsed)) {\n            throw new Error(`scrt: ${label} cannot parse float literal`);\n        }\n        return parsed;\n    }\n    throw new Error(`scrt: ${label} expects a float-compatible value`);\n}\nfunction coerceBool(value, label) {\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return value !== 0;\n    }\n    if (typeof value === \"string\") {\n        const normalized = value.trim().toLowerCase();\n        if (normalized === \"true\" || normalized === \"1\") {\n            return true;\n        }\n        if (normalized === \"false\" || normalized === \"0\") {\n            return false;\n        }\n        throw new Error(`scrt: ${label} cannot parse boolean literal`);\n    }\n    throw new Error(`scrt: ${label} expects a boolean-compatible value`);\n}\nfunction coerceString(value, label) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (typeof value === \"number\" || typeof value === \"boolean\" || typeof value === \"bigint\") {\n        return String(value);\n    }\n    if (value instanceof Date) {\n        if (!Number.isFinite(value.getTime())) {\n            throw new Error(`scrt: ${label} received invalid Date`);\n        }\n        return value.toISOString();\n    }\n    if (value instanceof Uint8Array) {\n        return textDecoder.decode(value);\n    }\n    throw new Error(`scrt: ${label} expects a string-compatible value`);\n}\nfunction coerceBytes(value, label) {\n    if (value instanceof Uint8Array) {\n        return value.slice();\n    }\n    if (ArrayBuffer.isView(value)) {\n        const view = value;\n        return new Uint8Array(view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength));\n    }\n    if (value instanceof ArrayBuffer) {\n        return new Uint8Array(value.slice(0));\n    }\n    if (Array.isArray(value)) {\n        const out = new Uint8Array(value.length);\n        value.forEach((entry, idx) => {\n            if (typeof entry !== \"number\" || !Number.isFinite(entry)) {\n                throw new Error(`scrt: ${label} byte array contains non-number at index ${idx}`);\n            }\n            out[idx] = entry & 0xff;\n        });\n        return out;\n    }\n    if (typeof value === \"string\") {\n        return textEncoder.encode(value);\n    }\n    throw new Error(`scrt: ${label} expects bytes, ArrayBufferView, or string input`);\n}\nfunction coerceDate(value, label, kind) {\n    if (value instanceof Date) {\n        if (!Number.isFinite(value.getTime())) {\n            throw new Error(`scrt: ${label} received invalid Date`);\n        }\n        return value;\n    }\n    if (typeof value === \"string\") {\n        const trimmed = value.trim();\n        if (!trimmed) {\n            throw new Error(`scrt: ${label} cannot parse empty temporal literal`);\n        }\n        switch (kind) {\n            case FieldKind.Date:\n                return parseDate(trimmed);\n            case FieldKind.DateTime:\n                return parseDateTime(trimmed);\n            case FieldKind.Timestamp:\n                return parseTimestamp(trimmed);\n            default:\n                return parseTimestamp(trimmed);\n        }\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return dateFromNumber(value);\n    }\n    if (typeof value === \"bigint\") {\n        return dateFromBigInt(value);\n    }\n    throw new Error(`scrt: ${label} expects Date, number, bigint, or string`);\n}\nfunction coerceTimestampTZ(value, label) {\n    if (value instanceof Date) {\n        if (!Number.isFinite(value.getTime())) {\n            throw new Error(`scrt: ${label} received invalid Date`);\n        }\n        return formatTimestampTZ(value);\n    }\n    if (typeof value === \"string\") {\n        return canonicalTimestampTZ(value);\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value)) {\n            throw new Error(`scrt: ${label} must be finite`);\n        }\n        return formatTimestampTZ(dateFromNumber(value));\n    }\n    if (typeof value === \"bigint\") {\n        return formatTimestampTZ(dateFromBigInt(value));\n    }\n    throw new Error(`scrt: ${label} expects Date, number, bigint, or string`);\n}\nfunction coerceDuration(value, label) {\n    if (typeof value === \"bigint\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        if (!Number.isFinite(value) || !Number.isInteger(value)) {\n            throw new Error(`scrt: ${label} duration must be a finite integer`);\n        }\n        if (Math.abs(value) > Number.MAX_SAFE_INTEGER) {\n            throw new Error(`scrt: ${label} duration exceeds safe integer range`);\n        }\n        return BigInt(value);\n    }\n    if (typeof value === \"string\") {\n        return parseDuration(value);\n    }\n    throw new Error(`scrt: ${label} expects bigint, number, or duration literal`);\n}\nfunction dateFromNumber(value) {\n    if (Number.isInteger(value)) {\n        return decodeInstant(inferEpochNanoseconds(BigInt(value)));\n    }\n    const whole = Math.trunc(value);\n    const fractional = value - whole;\n    const nanos = BigInt(whole) * 1000000000n + BigInt(Math.trunc(fractional * 1_000_000_000));\n    return decodeInstant(nanos);\n}\nfunction dateFromBigInt(value) {\n    return decodeInstant(inferEpochNanoseconds(value));\n}\nfunction normalizeBinarySource(source) {\n    if (source instanceof Uint8Array) {\n        return source;\n    }\n    if (ArrayBuffer.isView(source)) {\n        const view = source;\n        return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);\n    }\n    if (source instanceof ArrayBuffer) {\n        return new Uint8Array(source);\n    }\n    throw new Error(\"scrt: unsupported binary source\");\n}\nfunction resolveUnmarshalOptions(options) {\n    return {\n        zeroCopyBytes: options?.zeroCopyBytes ?? false,\n        numericMode: options?.numericMode ?? \"auto\",\n        temporalMode: options?.temporalMode ?? \"date\",\n        durationMode: options?.durationMode ?? \"bigint\",\n        objectFactory: options?.objectFactory ?? (() => ({})),\n    };\n}\nfunction materializeRow(row, schema, options) {\n    const target = options.objectFactory();\n    const values = row.valuesSlice();\n    schema.fields.forEach((field, idx) => {\n        const slot = values[idx];\n        if (!slot.set) {\n            return;\n        }\n        const decoded = decodeFieldValue(field, slot, options);\n        assignToTarget(target, field.name, decoded);\n    });\n    return target;\n}\nfunction assignToTarget(target, key, value) {\n    if (target instanceof Map) {\n        target.set(key, value);\n        return;\n    }\n    target[key] = value;\n}\nfunction decodeFieldValue(field, slot, options) {\n    const kind = field.valueKind();\n    switch (kind) {\n        case FieldKind.Uint64:\n        case FieldKind.Ref:\n            return convertBigInt(slot.uint ?? 0n, options.numericMode, field.name, true);\n        case FieldKind.Int64:\n            return convertBigInt(slot.int ?? 0n, options.numericMode, field.name, false);\n        case FieldKind.Float64:\n            return slot.float ?? 0;\n        case FieldKind.Bool:\n            return slot.bool ?? false;\n        case FieldKind.String:\n            return slot.str ?? \"\";\n        case FieldKind.Bytes:\n            return slot.bytes ?? new Uint8Array();\n        case FieldKind.Date: {\n            const decoded = decodeDate(slot.int ?? 0n);\n            return options.temporalMode === \"string\" ? formatDate(decoded) : decoded;\n        }\n        case FieldKind.DateTime:\n        case FieldKind.Timestamp: {\n            const decoded = decodeInstant(slot.int ?? 0n);\n            return options.temporalMode === \"string\" ? formatInstant(decoded) : decoded;\n        }\n        case FieldKind.TimestampTZ: {\n            const str = slot.str ?? \"\";\n            if (!str) {\n                return options.temporalMode === \"date\" ? new Date(0) : \"\";\n            }\n            if (options.temporalMode === \"string\") {\n                return str;\n            }\n            return parseTimestampTZ(str);\n        }\n        case FieldKind.Duration:\n            return convertDuration(slot.int ?? 0n, options.durationMode, field.name);\n        default:\n            throw new Error(`scrt: unsupported field kind ${kind}`);\n    }\n}\nfunction convertBigInt(value, mode, label, unsigned) {\n    if (unsigned && value < 0n) {\n        throw new Error(`scrt: ${label} stored value cannot be negative`);\n    }\n    switch (mode) {\n        case \"bigint\":\n            return value;\n        case \"number\":\n            if (!fitsSafeInteger(value)) {\n                throw new Error(`scrt: ${label} exceeds JS safe integer range`);\n            }\n            return Number(value);\n        default:\n            return fitsSafeInteger(value) ? Number(value) : value;\n    }\n}\nfunction convertDuration(value, mode, label) {\n    switch (mode) {\n        case \"bigint\":\n            return value;\n        case \"number\":\n            if (!fitsSafeInteger(value)) {\n                throw new Error(`scrt: duration ${label} exceeds JS safe integer range`);\n            }\n            return Number(value);\n        case \"string\":\n            return formatDuration(value);\n        default:\n            return value;\n    }\n}\nfunction fitsSafeInteger(value) {\n    return value <= BigInt(Number.MAX_SAFE_INTEGER) && value >= BigInt(Number.MIN_SAFE_INTEGER);\n}\n","const textDecoder = new TextDecoder();\nconst MAGIC = \"SCB1\";\nconst VERSION = 1;\nexport function decodeBundle(buffer) {\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < MAGIC.length; i += 1) {\n        if (view.getUint8(offset) !== MAGIC.charCodeAt(i)) {\n            throw new Error(\"scrt: invalid bundle magic\");\n        }\n        offset += 1;\n    }\n    const version = view.getUint8(offset);\n    offset += 1;\n    if (version !== VERSION) {\n        throw new Error(`scrt: unsupported bundle version ${version}`);\n    }\n    const docFingerprint = view.getBigUint64(offset, true);\n    offset += 8;\n    const schemaFingerprint = view.getBigUint64(offset, true);\n    offset += 8;\n    const updatedAt = new Date(Number(view.getBigInt64(offset, true) / 1000000n));\n    offset += 8;\n    const docString = readShortString(view, buffer, offset);\n    offset += docString.bytes;\n    const schemaString = readShortString(view, buffer, offset);\n    offset += schemaString.bytes;\n    const schemaBlob = readBlob(view, buffer, offset);\n    offset += schemaBlob.bytes;\n    const payload = readBlob(view, buffer, offset);\n    return {\n        documentName: docString.value,\n        schemaName: schemaString.value,\n        documentFingerprint: docFingerprint,\n        schemaFingerprint,\n        updatedAt,\n        schemaText: textDecoder.decode(schemaBlob.data),\n        payload: payload.data,\n    };\n}\nfunction readShortString(view, buffer, offset) {\n    const length = view.getUint16(offset, true);\n    const start = offset + 2;\n    const end = start + length;\n    if (end > buffer.byteLength) {\n        throw new Error(\"scrt: bundle string exceeds buffer\");\n    }\n    return { value: textDecoder.decode(buffer.slice(start, end)), bytes: 2 + length };\n}\nfunction readBlob(view, buffer, offset) {\n    const length = view.getUint32(offset, true);\n    const start = offset + 4;\n    const end = start + length;\n    if (end > buffer.byteLength) {\n        throw new Error(\"scrt: bundle blob exceeds buffer\");\n    }\n    return { data: new Uint8Array(buffer.slice(start, end)), bytes: 4 + length };\n}\n","import { decodeBundle } from \"./protocol\";\nfunction normalizeBase(url) {\n    const trimmed = url.trim();\n    if (!trimmed) {\n        return \"http://localhost:8080\";\n    }\n    return trimmed.endsWith(\"/\") ? trimmed.slice(0, -1) : trimmed;\n}\nasync function ensureOk(resp) {\n    if (resp.ok) {\n        return resp;\n    }\n    const text = await resp.text();\n    throw new Error(text || resp.statusText);\n}\nexport class ScrtHttpClient {\n    baseUrl;\n    constructor(baseUrl = \"http://localhost:8080\") {\n        this.baseUrl = normalizeBase(baseUrl);\n    }\n    setBaseUrl(url) {\n        this.baseUrl = normalizeBase(url);\n    }\n    url(path) {\n        return `${this.baseUrl}${path}`;\n    }\n    async listDocuments() {\n        const resp = await ensureOk(await fetch(this.url(\"/documents\"), {\n            headers: { Accept: \"text/plain\" },\n        }));\n        const body = await resp.text();\n        return body\n            .split(/\\r?\\n/)\n            .map((line) => line.trim())\n            .filter(Boolean);\n    }\n    async downloadDocument(name) {\n        const resp = await ensureOk(await fetch(this.url(`/documents/${encodeURIComponent(name)}`), {\n            headers: { Accept: \"text/plain\" },\n        }));\n        return resp.text();\n    }\n    async saveDocument(name, body) {\n        await ensureOk(await fetch(this.url(`/documents/${encodeURIComponent(name)}`), {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"text/plain; charset=utf-8\" },\n            body,\n        }));\n    }\n    async deleteDocument(name) {\n        await ensureOk(await fetch(this.url(`/documents/${encodeURIComponent(name)}`), {\n            method: \"DELETE\",\n        }));\n    }\n    async uploadRecords(doc, schema, payload) {\n        await ensureOk(await fetch(this.url(`/records/${encodeURIComponent(doc)}/${encodeURIComponent(schema)}`), {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/x-scrt\" },\n            body: payload,\n        }));\n    }\n    async fetchRecords(doc, schema) {\n        const resp = await ensureOk(await fetch(this.url(`/records/${encodeURIComponent(doc)}/${encodeURIComponent(schema)}`)));\n        const buffer = await resp.arrayBuffer();\n        return new Uint8Array(buffer);\n    }\n    async fetchBundle(doc, schema) {\n        const resp = await ensureOk(await fetch(this.url(`/bundle?document=${encodeURIComponent(doc)}&schema=${encodeURIComponent(schema)}`)));\n        const buffer = await resp.arrayBuffer();\n        return decodeBundle(buffer);\n    }\n}\n"],"names":["createBuffer","bufferLength","buf","pushByte","byte","pushBytes","bytes","i","bufferToUint8Array","concatByteBuffers","buffers","total","acc","cur","out","offset","MAX_VARINT_BYTES","writeUvarint","value","v","writeVarint","uv","zigZagEncode","readUvarint","data","x","s","b","readVarint","bytesRead","zigZagDecode","BinaryWriter","__publicField","buffer","arr","BinaryReader","size","length","slice","toSafeNumber","label","encodeUint64LE","temp","encoder","Uint64Column","dst","count","mode","isMonotonic","header","prev","delta","Int64Column","Float64Column","writeFloat64","BoolColumn","StringColumn","entry","idx","BytesColumn","copy","values","view","ISO_DATE","ISO_DATE_TIME","NUMERIC","DURATION_TOKEN","NANOS","parseDate","raw","trimmed","iso","parsed","utcDate","year","month","day","parseDateTime","match","y","m","d","hh","mm","ss","frac","nanos","normalizeFraction","date","parseTimestamp","numericTimestamp","parseTimestampTZ","parseDuration","matched","token","unitRaw","unit","scale","whole","fracScale","powerOfTen","encodeInstant","encodeDate","midnight","formatTimestampTZ","canonicalTimestampTZ","decodeInstant","ns","ms","decodeDate","formatDate","formatInstant","sec","fracDigits","inferEpochNanoseconds","abs","DURATION_UNITS","formatDuration","negative","remaining","chunks","input","digits","exp","result","FNV_OFFSET","FNV_PRIME","FieldKind","DefaultValue","kind","boolValue","intValue","uintValue","floatValue","stringValue","bytesValue","bytesToBase64","Field","name","rawType","targetSchema","targetField","autoIncrement","attributes","defaultValue","Schema","fields","hash","write","str","field","attrs","attr","Document","schemas","source","schema","resolveSchemaKinds","parseSchema","text","lines","line","current","awaitingName","currentData","finishCurrent","startSchema","rest","parseField","sch","row","parseDataRow","pushDataRow","doc","store","schemaName","body","typ","attrChunk","splitFieldParts","interpretFieldType","splitFieldAttributes","lower","assignFieldDefault","extractDefaultLiteral","firstSep","secondSep","fieldName","quote","ch","literalRaw","literal","parseDefaultLiteral","sepIdx","parseStringLiteral","parseBytesLiteral","stripQuotes","ts","hex","tokens","fieldIdx","countValueTokens","skipAuto","nonAuto","countNonAuto","index","applyExplicitAssignment","parseValue","start","expr","fieldToken","rawValue","normalized","normalizeAssignmentTarget","parts","resolveFieldKind","stack","key","targetIdx","resolved","binary","PageBuilder","rowLimit","handle","_a","present","column","_b","_c","_d","_e","_f","writePresence","presence","rows","byteLen","shift","written","MAGIC","VERSION","textDecoder","Row","slot","cloneBytes","Writer","rowsPerPage","fp","pageBuf","lenBuf","DecodedPage","fieldCount","Reader","options","rowIdx","valueSlot","valueIdx","assignDefaultValue","version","fpBytes","pageLength","cursor","rowsRead","rowCount","columns","columnsRead","columnCount","fieldIdxBig","fieldIdxRead","payloadLen","payloadLenRead","payload","decodePresence","decoded","decodeUintColumn","decodeStringColumn","decodeBoolColumn","decodeIntColumn","decodeFloatColumn","decodeBytesColumn","byteLenBig","indexes","setCount","byteIdx","bit","expected","countBig","dictLenBig","dictLen","table","lengthInfo","indexLenBig","indexRead","indexLen","idxInfo","zeroCopy","src","def","textEncoder","marshalRecords","writer","scratch","record","toIterable","isRecordShape","populateRow","unmarshalRecords","results","streamDecodedRows","resolveUnmarshalOptions","reader","normalizeBinarySource","materializeRow","isIterable","accessor","createAccessor","encoded","encodeFieldValue","coerceUint","coerceInt","coerceFloat","coerceBool","coerceString","coerceBytes","coerceDate","coerceTimestampTZ","coerceDuration","dateFromNumber","dateFromBigInt","fractional","target","decodeFieldValue","assignToTarget","convertBigInt","convertDuration","unsigned","fitsSafeInteger","decodeBundle","docFingerprint","schemaFingerprint","updatedAt","docString","readShortString","schemaString","schemaBlob","readBlob","end","normalizeBase","url","ensureOk","resp","ScrtHttpClient","baseUrl","path"],"mappings":"wPAAO,SAASA,GAAe,CAC3B,MAAO,CAAA,CACX,CACO,SAASC,GAAaC,EAAK,CAC9B,OAAOA,EAAI,MACf,CACO,SAASC,EAASD,EAAKE,EAAM,CAChCF,EAAI,KAAKE,EAAO,GAAI,CACxB,CACO,SAASC,EAAUH,EAAKI,EAAO,CAClC,QAASC,EAAI,EAAGA,EAAID,EAAM,OAAQC,GAAK,EACnCL,EAAI,KAAKI,EAAMC,CAAC,EAAI,GAAI,CAEhC,CACO,SAASC,EAAmBN,EAAK,CACpC,OAAO,WAAW,KAAKA,CAAG,CAC9B,CACO,SAASO,EAAkBC,EAAS,CACvC,MAAMC,EAAQD,EAAQ,OAAO,CAACE,EAAKC,IAAQD,EAAMC,EAAI,OAAQ,CAAC,EACxDC,EAAM,IAAI,WAAWH,CAAK,EAChC,IAAII,EAAS,EACb,UAAWb,KAAOQ,EACdI,EAAI,IAAI,WAAW,KAAKZ,CAAG,EAAGa,CAAM,EACpCA,GAAUb,EAAI,OAElB,OAAOY,CACX,CACA,MAAME,GAAmB,GAClB,SAASC,EAAaf,EAAKgB,EAAO,CACrC,IAAIC,EAAI,OAAOD,CAAK,EACpB,GAAIC,EAAI,GACJ,MAAM,IAAI,WAAW,4BAA4B,EAErD,KAAOA,GAAK,OACRhB,EAASD,EAAK,OAAQiB,EAAI,MAAS,KAAK,CAAC,EACzCA,IAAM,GAEVhB,EAASD,EAAK,OAAOiB,CAAC,CAAC,CAC3B,CACO,SAASC,EAAYlB,EAAKgB,EAAO,CACpC,IAAIG,EAAKC,GAAa,OAAOJ,CAAK,CAAC,EACnC,KAAOG,GAAM,OACTlB,EAASD,EAAK,OAAQmB,EAAK,MAAS,KAAK,CAAC,EAC1CA,IAAO,GAEXlB,EAASD,EAAK,OAAOmB,CAAE,CAAC,CAC5B,CACO,SAASE,EAAYC,EAAMT,EAAQ,CACtC,IAAIU,EAAI,GACJC,EAAI,GACR,QAAS,EAAI,EAAG,EAAIV,GAAkB,GAAK,EAAG,CAC1C,GAAID,EAAS,GAAKS,EAAK,OACnB,MAAM,IAAI,WAAW,wBAAwB,EAEjD,MAAMG,EAAI,OAAOH,EAAKT,EAAS,CAAC,CAAC,EACjC,IAAKY,EAAI,SAAW,GAChB,OAAAF,IAAME,EAAI,QAAUD,EACb,CAAE,MAAOD,EAAG,UAAW,EAAI,CAAC,EAEvCA,IAAME,EAAI,QAAUD,EACpBA,GAAK,EACT,CACA,MAAM,IAAI,WAAW,mBAAmB,CAC5C,CACO,SAASE,EAAWJ,EAAMT,EAAQ,CACrC,KAAM,CAAE,MAAAG,EAAO,UAAAW,CAAS,EAAKN,EAAYC,EAAMT,CAAM,EACrD,MAAO,CAAE,MAAOe,GAAaZ,CAAK,EAAG,UAAAW,CAAS,CAClD,CACA,SAASP,GAAaJ,EAAO,CACzB,OAAQA,GAAS,GAAOA,GAAS,GACrC,CACA,SAASY,GAAaZ,EAAO,CACzB,OAAQA,GAAS,GAAM,EAAEA,EAAQ,GACrC,CACO,MAAMa,EAAa,CAAnB,cACHC,EAAA,cAAS,CAAA,GACTA,EAAA,eAAUhC,EAAY,GACtB,UAAUI,EAAM,CACZD,EAAS,KAAK,QAASC,CAAI,CAC/B,CACA,WAAWE,EAAO,CACdD,EAAU,KAAK,QAASC,CAAK,CACjC,CACA,YAAY2B,EAAQ,CAChB,KAAK,aAAY,EACjB,KAAK,OAAO,KAAKA,EAAO,MAAK,CAAE,EAC/B,KAAK,QAAUjC,EAAY,CAC/B,CACA,gBAAgBkC,EAAK,CACjB,KAAK,aAAY,EACjB,KAAK,OAAO,KAAK,MAAM,KAAKA,CAAG,CAAC,EAChC,KAAK,QAAUlC,EAAY,CAC/B,CACA,aAAakB,EAAO,CAChBD,EAAa,KAAK,QAASC,CAAK,CACpC,CACA,cAAe,CACX,YAAK,aAAY,EACVT,EAAkB,KAAK,MAAM,CACxC,CACA,OAAQ,CACJ,KAAK,OAAO,OAAS,EACrB,KAAK,QAAUT,EAAY,CAC/B,CACA,cAAe,CACP,KAAK,QAAQ,OAAS,IACtB,KAAK,OAAO,KAAK,KAAK,OAAO,EAC7B,KAAK,QAAUA,EAAY,EAEnC,CACJ,CACO,MAAMmC,EAAa,CAGtB,YAAYX,EAAMT,EAAS,EAAG,CAF9BiB,EAAA,aACAA,EAAA,eAEI,KAAK,KAAOR,EACZ,KAAK,OAAST,CAClB,CACA,OAAOqB,EAAM,CACT,GAAI,KAAK,OAASA,EAAO,KAAK,KAAK,OAC/B,MAAM,IAAI,WAAW,iBAAiB,CAE9C,CACA,UAAW,CACP,YAAK,OAAO,CAAC,EACN,KAAK,KAAK,KAAK,QAAQ,CAClC,CACA,UAAUC,EAAQ,CACd,KAAK,OAAOA,CAAM,EAClB,MAAMC,EAAQ,KAAK,KAAK,SAAS,KAAK,OAAQ,KAAK,OAASD,CAAM,EAClE,YAAK,QAAUA,EACRC,CACX,CACA,aAAc,CACV,KAAM,CAAE,MAAApB,EAAO,UAAAW,GAAcN,EAAY,KAAK,KAAM,KAAK,MAAM,EAC/D,YAAK,QAAUM,EACRX,CACX,CACA,YAAa,CACT,KAAM,CAAE,MAAAA,EAAO,UAAAW,GAAcD,EAAW,KAAK,KAAM,KAAK,MAAM,EAC9D,YAAK,QAAUC,EACRX,CACX,CACA,WAAY,CACR,OAAO,KAAK,KAAK,OAAS,KAAK,MACnC,CACJ,CACO,SAASqB,GAAarB,EAAOsB,EAAO,CACvC,MAAMrB,EAAI,OAAOD,CAAK,EACtB,GAAI,CAAC,OAAO,SAASC,CAAC,GAAKA,EAAI,OAAO,iBAClC,MAAM,IAAI,WAAW,GAAGqB,CAAK,4BAA4B,EAE7D,OAAOrB,CACX,CACO,SAASsB,GAAevB,EAAO,CAClC,MAAMC,EAAI,OAAOD,CAAK,EAChBJ,EAAM,IAAI,WAAW,CAAC,EAC5B,IAAI4B,EAAOvB,EACX,QAAS,EAAI,EAAG,EAAI,EAAG,GAAK,EACxBL,EAAI,CAAC,EAAI,OAAO4B,EAAO,KAAK,EAC5BA,IAAS,GAEb,OAAO5B,CACX,CClKA,MAAM6B,GAAU,IAAI,YACb,MAAMC,EAAa,CAAnB,cACHZ,EAAA,cAAS,CAAA,GACT,OAAOd,EAAO,CACV,KAAK,OAAO,KAAK,OAAOA,CAAK,CAAC,CAClC,CACA,OAAO2B,EAAK,CACR,MAAMC,EAAQ,KAAK,OAAO,OACpBC,EAAOD,GAAS,GAAKE,GAAY,KAAK,MAAM,EAAI,GAAK,GACrDC,EAAU,OAAOH,CAAK,GAAK,GAAMC,EAEvC,GADA9B,EAAa4B,EAAKI,CAAM,EACpBH,IAAU,EACV,OAEJ,GAAIC,IAAS,GAAI,CACb,UAAW7B,KAAS,KAAK,OACrBD,EAAa4B,EAAK3B,CAAK,EAE3B,MACJ,CACAD,EAAa4B,EAAK,KAAK,OAAO,CAAC,CAAC,EAChC,IAAIK,EAAO,KAAK,OAAO,CAAC,EACxB,QAAS3C,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAAG,CAC/B,MAAM4C,EAAQ,KAAK,OAAO5C,CAAC,EAAI2C,EAC/BjC,EAAa4B,EAAKM,CAAK,EACvBD,EAAO,KAAK,OAAO3C,CAAC,CACxB,CACJ,CACA,OAAQ,CACJ,KAAK,OAAO,OAAS,CACzB,CACJ,CACO,MAAM6C,EAAY,CAAlB,cACHpB,EAAA,cAAS,CAAA,GACT,OAAOd,EAAO,CACV,KAAK,OAAO,KAAK,OAAOA,CAAK,CAAC,CAClC,CACA,OAAO2B,EAAK,CACR,MAAMC,EAAQ,KAAK,OAAO,OACpBC,EAAOD,EAAQ,EAAI,GAAK,GACxBG,EAAU,OAAOH,CAAK,GAAK,GAAMC,EAEvC,GADA9B,EAAa4B,EAAKI,CAAM,EACpBH,IAAU,EACV,OAEJ,GAAIC,IAAS,GAAI,CACb,UAAW7B,KAAS,KAAK,OACrBE,EAAYyB,EAAK3B,CAAK,EAE1B,MACJ,CACAE,EAAYyB,EAAK,KAAK,OAAO,CAAC,CAAC,EAC/B,IAAIK,EAAO,KAAK,OAAO,CAAC,EACxB,QAAS3C,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAAG,CAC/B,MAAM4C,EAAQ,KAAK,OAAO5C,CAAC,EAAI2C,EAC/B9B,EAAYyB,EAAKM,CAAK,EACtBD,EAAO,KAAK,OAAO3C,CAAC,CACxB,CACJ,CACA,OAAQ,CACJ,KAAK,OAAO,OAAS,CACzB,CACJ,CACO,MAAM8C,EAAc,CAApB,cACHrB,EAAA,cAAS,CAAA,GACT,OAAOd,EAAO,CACV,KAAK,OAAO,KAAKA,CAAK,CAC1B,CACA,OAAO2B,EAAK,CACR5B,EAAa4B,EAAK,KAAK,OAAO,MAAM,EACpC,UAAW3B,KAAS,KAAK,OACrBoC,GAAaT,EAAK3B,CAAK,CAE/B,CACA,OAAQ,CACJ,KAAK,OAAO,OAAS,CACzB,CACJ,CACO,MAAMqC,EAAW,CAAjB,cACHvB,EAAA,cAAS,CAAA,GACT,OAAOd,EAAO,CACV,KAAK,OAAO,KAAKA,EAAQ,EAAI,CAAC,CAClC,CACA,OAAO2B,EAAK,CACR5B,EAAa4B,EAAK,KAAK,OAAO,MAAM,EACpC,UAAW3B,KAAS,KAAK,OACrBf,EAAS0C,EAAK3B,CAAK,CAE3B,CACA,OAAQ,CACJ,KAAK,OAAO,OAAS,CACzB,CACJ,CACO,MAAMsC,EAAa,CAAnB,cACHxB,EAAA,YAAO,IAAI,KACXA,EAAA,eAAU,CAAA,GACVA,EAAA,eAAU,CAAA,GACV,OAAOd,EAAO,CACV,GAAI,CAAC,KAAK,KAAK,IAAIA,CAAK,EAAG,CACvB,MAAMZ,EAAQqC,GAAQ,OAAOzB,CAAK,EAClC,KAAK,KAAK,IAAIA,EAAO,KAAK,QAAQ,MAAM,EACxC,KAAK,QAAQ,KAAKZ,CAAK,CAC3B,CACA,KAAK,QAAQ,KAAK,KAAK,KAAK,IAAIY,CAAK,CAAC,CAC1C,CACA,OAAO2B,EAAK,CACR5B,EAAa4B,EAAK,KAAK,QAAQ,MAAM,EACrC,UAAWY,KAAS,KAAK,QACrBxC,EAAa4B,EAAKY,EAAM,MAAM,EAC9BpD,EAAUwC,EAAKY,CAAK,EAExBxC,EAAa4B,EAAK,KAAK,QAAQ,MAAM,EACrC,UAAWa,KAAO,KAAK,QACnBzC,EAAa4B,EAAK,OAAOa,CAAG,CAAC,CAErC,CACA,OAAQ,CACJ,KAAK,KAAK,MAAK,EACf,KAAK,QAAQ,OAAS,EACtB,KAAK,QAAQ,OAAS,CAC1B,CACJ,CACO,MAAMC,EAAY,CAAlB,cACH3B,EAAA,cAAS,CAAA,GACT,OAAOd,EAAO,CACV,MAAM0C,EAAO,IAAI,WAAW1C,EAAM,MAAM,EACxC0C,EAAK,IAAI1C,CAAK,EACd,KAAK,OAAO,KAAK0C,CAAI,CACzB,CACA,OAAOf,EAAK,CACR5B,EAAa4B,EAAK,KAAK,OAAO,MAAM,EACpC,UAAW3B,KAAS,KAAK,OACrBD,EAAa4B,EAAK3B,EAAM,MAAM,EAC9Bb,EAAUwC,EAAK3B,CAAK,CAE5B,CACA,OAAQ,CACJ,KAAK,OAAO,OAAS,CACzB,CACJ,CACA,SAAS8B,GAAYa,EAAQ,CACzB,QAAStD,EAAI,EAAGA,EAAIsD,EAAO,OAAQtD,GAAK,EACpC,GAAIsD,EAAOtD,CAAC,EAAIsD,EAAOtD,EAAI,CAAC,EACxB,MAAO,GAGf,MAAO,EACX,CACA,SAAS+C,GAAaT,EAAK3B,EAAO,CAC9B,MAAMe,EAAS,IAAI,YAAY,CAAC,EAC1B6B,EAAO,IAAI,SAAS7B,CAAM,EAChC6B,EAAK,WAAW,EAAG5C,EAAO,EAAI,EAC9B,QAAS,EAAI,EAAG,EAAI,EAAG,GAAK,EACxBf,EAAS0C,EAAKiB,EAAK,SAAS,CAAC,CAAC,CAEtC,CC5JA,MAAMC,GAAW,4BACXC,GAAgB,4EAChBC,EAAU,uBACVC,GAAiB,yCACjBC,GAAQ,CACV,GAAI,GACJ,GAAI,MACJ,GAAM,MACN,GAAI,SACJ,EAAG,YACH,EAAG,IAAM,YACT,EAAG,IAAM,IAAM,YACf,EAAG,IAAM,IAAM,IAAM,WACzB,EACO,SAASC,EAAUC,EAAK,CAC3B,MAAMC,EAAUD,EAAI,KAAI,EAClBE,EAAMR,GAAS,KAAKO,CAAO,EACjC,GAAI,CAACC,EAAK,CACN,MAAMC,EAAS,IAAI,KAAKF,CAAO,EAC/B,GAAI,OAAO,MAAME,EAAO,QAAO,CAAE,EAC7B,MAAM,IAAI,MAAM,0BAA0BH,CAAG,EAAE,EAEnD,OAAOI,EAAQD,EAAO,eAAc,EAAIA,EAAO,YAAW,EAAIA,EAAO,YAAY,CACrF,CACA,KAAM,EAAGE,EAAMC,EAAOC,CAAG,EAAIL,EAC7B,OAAOE,EAAQ,OAAOC,CAAI,EAAG,OAAOC,CAAK,EAAI,EAAG,OAAOC,CAAG,CAAC,CAC/D,CACO,SAASC,EAAcR,EAAK,CAC/B,MAAMC,EAAUD,EAAI,KAAI,EAClBS,EAAQd,GAAc,KAAKM,CAAO,EACxC,GAAI,CAACQ,EAAO,CACR,MAAMN,EAAS,IAAI,KAAKF,CAAO,EAC/B,GAAI,OAAO,MAAME,EAAO,QAAO,CAAE,EAC7B,MAAM,IAAI,MAAM,8BAA8BH,CAAG,EAAE,EAEvD,OAAO,IAAI,KAAKG,EAAO,aAAa,CACxC,CACA,KAAM,EAAGO,EAAGC,EAAGC,EAAGC,EAAIC,EAAIC,EAAK,IAAKC,EAAO,GAAG,EAAIP,EAC5CQ,EAAQC,GAAkBF,CAAI,EAC9BG,EAAO,KAAK,IAAI,OAAOT,CAAC,EAAG,OAAOC,CAAC,EAAI,EAAG,OAAOC,CAAC,EAAG,OAAOC,CAAE,EAAG,OAAOC,CAAE,EAAG,OAAOC,CAAE,CAAC,EAC7F,OAAO,IAAI,KAAKI,EAAO,OAAOF,EAAQ,QAAQ,CAAC,CACnD,CACO,SAASG,EAAepB,EAAK,CAChC,MAAMC,EAAUD,EAAI,KAAI,EACxB,GAAIJ,EAAQ,KAAKK,CAAO,EACpB,OAAOoB,EAAiBpB,CAAO,EAEnC,MAAME,EAAS,IAAI,KAAKF,CAAO,EAC/B,OAAI,OAAO,MAAME,EAAO,QAAO,CAAE,EACtBK,EAAcP,CAAO,EAEzB,IAAI,KAAKE,EAAO,aAAa,CACxC,CACO,SAASmB,EAAiBtB,EAAK,CAClC,MAAMC,EAAUD,EAAI,KAAI,EACxB,GAAIJ,EAAQ,KAAKK,CAAO,EACpB,OAAOoB,EAAiBpB,CAAO,EAEnC,MAAME,EAAS,IAAI,KAAKF,CAAO,EAC/B,GAAI,OAAO,MAAME,EAAO,QAAO,CAAE,EAC7B,MAAM,IAAI,MAAM,iCAAiCH,CAAG,EAAE,EAE1D,OAAOG,CACX,CACO,SAASoB,EAAcvB,EAAK,CAC/B,MAAMC,EAAUD,EAAI,KAAI,EACxB,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,0BAA0B,EAE9C,IAAI3D,EAAQ,GACRkF,EAAU,GACd,UAAWC,KAASxB,EAAQ,SAASJ,EAAc,EAAG,CAClD2B,EAAU,GACV,KAAM,CAAA,CAAG3E,EAAO6E,CAAO,EAAID,EACrBE,EAAOD,EAAQ,YAAW,EAC1BE,EAAQ9B,GAAM6B,CAAI,EACxB,GAAI,CAACC,EACD,MAAM,IAAI,MAAM,uCAAuCF,CAAO,EAAE,EAEpE,KAAM,CAACG,EAAOb,EAAO,GAAG,EAAInE,EAAM,MAAM,GAAG,EAC3C,IAAIoE,EAAQ,OAAOY,CAAK,EAAID,EAC5B,GAAIZ,EAAM,CACN,MAAMc,EAAYF,EAAQG,GAAWf,EAAK,MAAM,EAChDC,GAAS,OAAOD,CAAI,EAAIc,CAC5B,CACAxF,GAAS2E,CACb,CACA,GAAI,CAACO,EACD,MAAM,IAAI,MAAM,gCAAgCxB,CAAG,EAAE,EAEzD,OAAO1D,CACX,CACO,SAAS0F,EAAcnF,EAAO,CACjC,OAAIA,aAAiB,KACV,OAAOA,EAAM,QAAO,CAAE,EAAI,SAEjC,OAAOA,GAAU,SACV,OAAO,KAAK,MAAMA,CAAK,CAAC,EAAI,SAEhCA,CACX,CACO,SAASoF,EAAWpF,EAAO,CAC9B,GAAIA,aAAiB,KAAM,CACvB,MAAMqF,EAAW9B,EAAQvD,EAAM,eAAc,EAAIA,EAAM,YAAW,EAAIA,EAAM,YAAY,EACxF,OAAO,OAAOqF,EAAS,QAAO,CAAE,EAAI,QACxC,CACA,MAAM/B,EAASJ,EAAUlD,CAAK,EAC9B,OAAO,OAAOsD,EAAO,QAAO,CAAE,EAAI,QACtC,CACO,SAASgC,EAAkBtF,EAAO,CACrC,OAAOA,EAAM,YAAW,CAC5B,CACO,SAASuF,GAAqBpC,EAAK,CACtC,GAAI,CAACA,EAAI,OACL,MAAO,GAEX,MAAMG,EAASmB,EAAiBtB,CAAG,EACnC,OAAOmC,EAAkBhC,CAAM,CACnC,CACO,SAASkC,EAAcxF,EAAO,CACjC,MAAMyF,EAAK,OAAOzF,CAAK,EACvB,GAAIyF,IAAO,GACP,OAAO,IAAI,KAAK,CAAC,EAErB,MAAMC,EAAK,OAAOD,EAAK,QAAQ,EAC/B,OAAO,IAAI,KAAKC,CAAE,CACtB,CACO,SAASC,GAAW3F,EAAO,CAC9B,OAAOwF,EAAcxF,CAAK,CAC9B,CACO,SAAS4F,GAAW5F,EAAO,CAC9B,OAAK,OAAO,SAASA,EAAM,QAAO,CAAE,EAG7BA,EAAM,YAAW,EAAG,MAAM,EAAG,EAAE,EAF3B,EAGf,CACO,SAAS6F,GAAc7F,EAAO,CACjC,OAAK,OAAO,SAASA,EAAM,QAAO,CAAE,EAG7BA,EAAM,YAAW,EAFb,EAGf,CACO,SAASwE,EAAiBrB,EAAK,CAClC,GAAIA,EAAI,SAAS,GAAG,EAAG,CACnB,KAAM,CAAC6B,EAAOb,CAAI,EAAIhB,EAAI,MAAM,GAAG,EAC7B2C,EAAM,OAAOd,CAAK,EAClBe,EAAa,OAAOb,GAAWf,EAAK,MAAM,CAAC,EAC3CC,EAAS,OAAOD,CAAI,EAAI,YAAe4B,EAC7C,OAAO,IAAI,KAAK,OAAOD,EAAM,MAAQ1B,EAAQ,QAAQ,CAAC,CAC1D,CACA,MAAMpE,EAAQ,OAAOmD,CAAG,EAClBiB,EAAQ4B,EAAsBhG,CAAK,EACzC,OAAO,IAAI,KAAK,OAAOoE,EAAQ,QAAQ,CAAC,CAC5C,CACO,SAAS4B,EAAsBhG,EAAO,CACzC,MAAMiG,EAAMjG,EAAQ,GAAK,CAACA,EAAQA,EAClC,OAAIiG,EAAM,cACCjG,EAAQ,YAEfiG,EAAM,iBACCjG,EAAQ,SAEfiG,EAAM,oBACCjG,EAAQ,MAEZA,CACX,CACA,MAAMkG,GAAiB,CACnB,CAAE,MAAO,IAAM,IAAM,IAAM,YAAa,OAAQ,GAAG,EACnD,CAAE,MAAO,IAAM,IAAM,YAAa,OAAQ,GAAG,EAC7C,CAAE,MAAO,IAAM,YAAa,OAAQ,GAAG,EACvC,CAAE,MAAO,YAAa,OAAQ,GAAG,EACjC,CAAE,MAAO,SAAU,OAAQ,IAAI,EAC/B,CAAE,MAAO,MAAO,OAAQ,IAAI,EAC5B,CAAE,MAAO,GAAI,OAAQ,IAAI,CAC7B,EACO,SAASC,GAAe/B,EAAO,CAClC,GAAIA,IAAU,GACV,MAAO,KAEX,MAAMgC,EAAWhC,EAAQ,GACzB,IAAIiC,EAAYD,EAAW,CAAChC,EAAQA,EACpC,MAAMkC,EAAS,CAAA,EACf,UAAWxB,KAAQoB,GAAgB,CAC/B,GAAIG,EAAYvB,EAAK,MACjB,SAEJ,MAAM9E,EAAQqG,EAAYvB,EAAK,MAG/B,GAFAuB,GAAarG,EAAQ8E,EAAK,MAC1BwB,EAAO,KAAK,GAAGtG,CAAK,GAAG8E,EAAK,MAAM,EAAE,EAChCuB,IAAc,GACd,KAER,CACA,OAAIA,EAAY,IACZC,EAAO,KAAK,GAAGD,CAAS,IAAI,EAEzB,GAAGD,EAAW,IAAM,EAAE,GAAGE,EAAO,KAAK,EAAE,CAAC,EACnD,CACA,SAAS/C,EAAQC,EAAMC,EAAOC,EAAK,CAC/B,OAAO,IAAI,KAAK,KAAK,IAAIF,EAAMC,EAAOC,EAAK,EAAG,EAAG,EAAG,CAAC,CAAC,CAC1D,CACA,SAASW,GAAkBkC,EAAO,CAC9B,MAAMC,EAASD,EAAM,OAAO,EAAG,GAAG,EAAE,MAAM,EAAG,CAAC,EAC9C,OAAO,OAAOC,CAAM,CACxB,CACA,SAAStB,GAAWuB,EAAK,CACrB,IAAIC,EAAS,GACb,QAASrH,EAAI,EAAGA,EAAIoH,EAAKpH,GAAK,EAC1BqH,GAAU,IAEd,OAAOA,CACX,CCnNA,MAAMC,GAAa,oBACbC,GAAY,eACPC,QAAAA,UAAAA,QACV,SAAUA,EAAW,CAClBA,EAAUA,EAAU,QAAa,CAAC,EAAI,UACtCA,EAAUA,EAAU,OAAY,CAAC,EAAI,SACrCA,EAAUA,EAAU,OAAY,CAAC,EAAI,SACrCA,EAAUA,EAAU,IAAS,CAAC,EAAI,MAClCA,EAAUA,EAAU,KAAU,CAAC,EAAI,OACnCA,EAAUA,EAAU,MAAW,CAAC,EAAI,QACpCA,EAAUA,EAAU,QAAa,CAAC,EAAI,UACtCA,EAAUA,EAAU,MAAW,CAAC,EAAI,QACpCA,EAAUA,EAAU,KAAU,CAAC,EAAI,OACnCA,EAAUA,EAAU,SAAc,CAAC,EAAI,WACvCA,EAAUA,EAAU,UAAe,EAAE,EAAI,YACzCA,EAAUA,EAAU,YAAiB,EAAE,EAAI,cAC3CA,EAAUA,EAAU,SAAc,EAAE,EAAI,UAC5C,GAAGA,QAAAA,YAAcA,kBAAY,CAAA,EAAG,EACzB,MAAMC,CAAa,CAQtB,YAAYC,EAAMC,EAAWC,EAAUC,EAAWC,EAAYC,EAAaC,EAAY,CAPvFvG,EAAA,aACAA,EAAA,kBACAA,EAAA,iBACAA,EAAA,kBACAA,EAAA,mBACAA,EAAA,oBACAA,EAAA,mBAEI,KAAK,KAAOiG,EACZ,KAAK,UAAYC,EACjB,KAAK,SAAWC,EAChB,KAAK,UAAYC,EACjB,KAAK,WAAaC,EAClB,KAAK,YAAcC,EACnB,KAAK,WAAaC,CACtB,CACA,SAAU,CACN,OAAQ,KAAK,KAAI,CACb,KAAKR,QAAAA,UAAU,KACX,MAAO,QAAQ,KAAK,UAAY,EAAI,CAAC,GACzC,KAAKA,QAAAA,UAAU,MACX,MAAO,OAAO,KAAK,UAAY,EAAE,GACrC,KAAKA,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACX,MAAO,QAAQ,KAAK,WAAa,EAAE,GACvC,KAAKA,QAAAA,UAAU,QACX,MAAO,SAAS,KAAK,YAAc,CAAC,GACxC,KAAKA,QAAAA,UAAU,OACX,MAAO,UAAU,KAAK,aAAe,EAAE,GAC3C,KAAKA,QAAAA,UAAU,MACX,MAAO,SAASS,GAAc,KAAK,YAAc,IAAI,UAAY,CAAC,GACtE,KAAKT,QAAAA,UAAU,KACf,KAAKA,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACf,KAAKA,QAAAA,UAAU,SACX,MAAO,OAAO,KAAK,UAAY,EAAE,GACrC,KAAKA,QAAAA,UAAU,YACX,MAAO,eAAe,KAAK,aAAe,EAAE,GAChD,QACI,MAAO,EACvB,CACI,CACJ,CACO,MAAMU,EAAM,CAWf,YAAYC,EAAMT,EAAMU,EAASC,EAAe,GAAIC,EAAc,GAAIC,EAAgB,GAAOC,EAAa,CAAA,EAAIC,EAAc,CAV5HhH,EAAA,aACAA,EAAA,aACAA,EAAA,gBACAA,EAAA,qBACAA,EAAA,oBACAA,EAAA,sBACAA,EAAA,mBACAA,EAAA,qBACAA,EAAA,oBAAe+F,QAAAA,UAAU,SACzB/F,EAAA,sBAAiB,IAEb,KAAK,KAAO0G,EACZ,KAAK,KAAOT,EACZ,KAAK,QAAUU,EACf,KAAK,aAAeC,EACpB,KAAK,YAAcC,EACnB,KAAK,cAAgBC,EACrB,KAAK,WAAaC,EAClB,KAAK,aAAeC,CACxB,CACA,WAAY,CACR,OAAI,KAAK,OAASjB,QAAAA,UAAU,IACjB,KAAK,eAAiBA,QAAAA,UAAU,QAAUA,kBAAU,OAAS,KAAK,aAEtE,KAAK,eAAiBA,QAAAA,UAAU,QAAU,KAAK,KAAO,KAAK,YACtE,CACA,aAAc,CACV,OAAO,KAAK,OAASA,QAAAA,UAAU,KAAO,CAAC,CAAC,KAAK,cAAgB,CAAC,CAAC,KAAK,WACxE,CACJ,CACO,MAAMkB,EAAO,CAKhB,YAAYP,EAAMQ,EAAQ,CAJ1BlH,EAAA,aACAA,EAAA,eACAA,EAAA,yBACAA,EAAA,mBAEI,KAAK,KAAO0G,EACZ,KAAK,OAASQ,CAClB,CACA,aAAc,CACV,GAAI,KAAK,mBAAqB,OAC1B,OAAO,KAAK,iBAEhB,IAAIC,EAAOtB,GACX,MAAMuB,EAASC,GAAQ,CACnB,QAAS,EAAI,EAAG,EAAIA,EAAI,OAAQ,GAAK,EACjCF,GAAQ,OAAOE,EAAI,WAAW,CAAC,CAAC,EAChCF,EAAO,OAAO,QAAQ,GAAIA,EAAOrB,EAAS,CAElD,EACAsB,EAAM,KAAK,IAAI,EACf,UAAWE,KAAS,KAAK,OAAQ,CAY7B,GAXAF,EAAM,GAAG,EACTA,EAAME,EAAM,IAAI,EAChBF,EAAM,GAAG,EACTA,EAAME,EAAM,OAAO,EACfA,EAAM,eACNF,EAAM,IAAI,EACVA,EAAM,GAAGE,EAAM,YAAY,IAAIA,EAAM,WAAW,EAAE,GAElDA,EAAM,eACNF,EAAM,OAAO,EAEbE,EAAM,WAAW,OAAQ,CACzB,MAAMC,EAAQ,CAAC,GAAGD,EAAM,UAAU,EAAE,KAAI,EACxC,UAAWE,KAAQD,EACfH,EAAM,IAAII,CAAI,EAAE,CAExB,CACIF,EAAM,eACNF,EAAM,OAAO,EACbA,EAAME,EAAM,aAAa,SAAS,EAE1C,CACA,YAAK,iBAAmB,OAAO,QAAQ,GAAIH,CAAI,EACxC,KAAK,gBAChB,CACA,iBAAiBT,EAAM,CACd,KAAK,aACN,KAAK,WAAa,IAAI,IACtB,KAAK,OAAO,QAAQ,CAACY,EAAO5F,IAAQ,KAAK,WAAW,IAAI4F,EAAM,KAAM5F,CAAG,CAAC,GAE5E,MAAMA,EAAM,KAAK,WAAW,IAAIgF,CAAI,EACpC,GAAIhF,IAAQ,OACR,MAAM,IAAI,MAAM,eAAegF,CAAI,wBAAwB,KAAK,IAAI,EAAE,EAE1E,OAAOhF,CACX,CACA,cAAcgF,EAAM,CAChB,OAAK,KAAK,aACN,KAAK,WAAa,IAAI,IACtB,KAAK,OAAO,QAAQ,CAACY,EAAO5F,IAAQ,KAAK,WAAW,IAAI4F,EAAM,KAAM5F,CAAG,CAAC,GAErE,KAAK,WAAW,IAAIgF,CAAI,CACnC,CACJ,CACO,MAAMe,EAAS,CAIlB,YAAYC,EAASlI,EAAMmI,EAAQ,CAHnC3H,EAAA,gBACAA,EAAA,aACAA,EAAA,eAEI,KAAK,QAAU0H,EACf,KAAK,KAAOlI,EACZ,KAAK,OAASmI,CAClB,CACA,OAAOjB,EAAM,CACT,OAAO,KAAK,QAAQ,IAAIA,CAAI,CAChC,CACA,QAAQA,EAAM,CACV,OAAO,KAAK,KAAK,IAAIA,CAAI,CAC7B,CACA,UAAW,CACP,UAAWkB,KAAU,KAAK,QAAQ,OAAM,EACpCC,GAAmB,KAAMD,CAAM,CAEvC,CACJ,CACO,SAASE,GAAYC,EAAM,CAC9B,MAAMC,EAAQD,EAAK,MAAM,OAAO,EAAE,IAAKE,GAASA,EAAK,MAAM,EACrDP,EAAU,IAAI,IACdlI,EAAO,IAAI,IACjB,IAAI0I,EACAC,EAAe,GACfC,EAAc,GAClB,MAAMC,EAAgB,IAAM,CACxB,GAAKH,EAGL,IAAIR,EAAQ,IAAIQ,EAAQ,IAAI,EACxB,MAAM,IAAI,MAAM,0BAA0BA,EAAQ,IAAI,EAAE,EAE5DR,EAAQ,IAAIQ,EAAQ,KAAMA,CAAO,EACjCA,EAAU,OACd,EACMI,EAAe5B,GAAS,CAE1B,GADA2B,EAAa,EACT,CAAC3B,EACD,MAAM,IAAI,MAAM,mCAAmC,EAEvDwB,EAAU,IAAIjB,GAAOP,EAAM,EAAE,CACjC,EACA,UAAWuB,KAAQD,EACf,GAAKC,EAGL,IAAIE,EAAc,CACdG,EAAYL,CAAI,EAChBE,EAAe,GACf,QACJ,CACA,GAAIF,EAAK,WAAW,SAAS,EAAG,CAC5BG,EAAc,GACd,IAAIG,EAAON,EAAK,MAAM,CAAgB,EAAE,KAAI,EAI5C,GAHIM,EAAK,WAAW,GAAG,IACnBA,EAAOA,EAAK,MAAM,CAAC,EAAE,KAAI,GAEzB,CAACA,EAAM,CACPJ,EAAe,GACf,QACJ,CACAG,EAAYC,CAAI,EAChB,QACJ,CACA,GAAIN,EAAK,WAAW,QAAQ,EAAG,CAE3B,GADAG,EAAc,GACV,CAACF,EACD,MAAM,IAAI,MAAM,mCAAmC,EAEvD,MAAMZ,EAAQkB,GAAWP,EAAK,MAAM,CAAe,EAAE,MAAM,EAC3DC,EAAQ,OAAO,KAAKZ,CAAK,EACzB,QACJ,CACA,GAAIW,EAAK,WAAW,GAAG,EAAG,CAGtB,GAFAE,EAAe,GACfE,EAAa,EACTJ,EAAK,SAAS,GAAG,GAAKG,EAAa,CACnC,MAAMK,EAAMf,EAAQ,IAAIU,CAAW,EACnC,GAAIK,EAAK,CACL,MAAMC,EAAMC,EAAaV,EAAMQ,CAAG,EAClCG,EAAYpJ,EAAM4I,EAAaM,CAAG,CACtC,CACA,QACJ,CACAN,EAAcH,EAAK,MAAM,CAAC,EAAE,KAAI,EAChC,QACJ,CACA,GAAIG,EAAa,CACb,MAAMK,EAAMf,EAAQ,IAAIU,CAAW,EACnC,GAAI,CAACK,EACD,SAEJ,MAAMC,EAAMC,EAAaV,EAAMQ,CAAG,EAClCG,EAAYpJ,EAAM4I,EAAaM,CAAG,EAClC,QACJ,EAEJL,EAAa,EACb,MAAMQ,EAAM,IAAIpB,GAASC,EAASlI,CAAI,EACtC,OAAAqJ,EAAI,SAAQ,EACLA,CACX,CACA,SAASD,EAAYE,EAAOC,EAAYL,EAAK,CACpCI,EAAM,IAAIC,CAAU,GACrBD,EAAM,IAAIC,EAAY,EAAE,EAE5BD,EAAM,IAAIC,CAAU,EAAE,KAAKL,CAAG,CAClC,CACA,SAASF,GAAWQ,EAAM,CACtB,KAAM,CAACtC,EAAMuC,EAAKC,CAAS,EAAIC,GAAgBH,CAAI,EAC7C,CAAE,KAAA/C,EAAM,aAAAW,EAAc,YAAAC,CAAW,EAAKuC,GAAmBH,CAAG,EAC5D3B,EAAQ,IAAIb,GAAMC,EAAMT,EAAMgD,EAAKrC,EAAcC,CAAW,EAClE,GAAIqC,EAAW,CACX,MAAM3B,EAAQ8B,GAAqBH,CAAS,EAC5C,UAAW1B,KAAQD,EAAO,CACtB,MAAM+B,EAAQ9B,EAAK,YAAW,EAC9B,OAAQ,GAAI,CACR,KAAK8B,IAAU,kBAAoBA,IAAU,iBAAmBA,IAAU,UACtEhC,EAAM,cAAgB,GACtB,MACJ,KAAKgC,EAAM,WAAW,UAAU,EAChC,KAAKA,EAAM,WAAW,UAAU,EAC5BC,GAAmBjC,EAAOkC,GAAsBhC,CAAI,CAAC,EACrD,KAGpB,CACYF,EAAM,WAAW,KAAKgC,CAAK,CAC/B,CACJ,CACA,OAAOhC,CACX,CACA,SAAS6B,GAAgBH,EAAM,CAC3B,MAAM1G,EAAU0G,EAAK,KAAI,EACnBS,EAAWnH,EAAQ,OAAO,OAAO,EACvC,GAAImH,IAAa,GACb,MAAM,IAAI,MAAM,oCAAoCT,CAAI,EAAE,EAE9D,MAAMtC,EAAOpE,EAAQ,MAAM,EAAGmH,CAAQ,EAAE,KAAI,EACtClB,EAAOjG,EAAQ,MAAMmH,EAAW,CAAC,EAAE,KAAI,EACvCC,EAAYnB,EAAK,OAAO,OAAO,EACrC,OAAImB,IAAc,GACP,CAAChD,EAAM6B,EAAM,EAAE,EAEnB,CAAC7B,EAAM6B,EAAK,MAAM,EAAGmB,CAAS,EAAE,KAAI,EAAInB,EAAK,MAAMmB,EAAY,CAAC,EAAE,KAAI,CAAE,CACnF,CACA,SAASN,GAAmB/G,EAAK,CAC7B,MAAM4G,EAAM5G,EAAI,YAAW,EAC3B,OAAQ,GAAI,CACR,KAAK4G,IAAQ,SACT,MAAO,CAAE,KAAMlD,kBAAU,OAAQ,aAAc,GAAI,YAAa,EAAE,EACtE,KAAKkD,IAAQ,SACT,MAAO,CAAE,KAAMlD,kBAAU,OAAQ,aAAc,GAAI,YAAa,EAAE,EACtE,KAAKkD,IAAQ,OACT,MAAO,CAAE,KAAMlD,kBAAU,KAAM,aAAc,GAAI,YAAa,EAAE,EACpE,KAAKkD,IAAQ,QACT,MAAO,CAAE,KAAMlD,kBAAU,MAAO,aAAc,GAAI,YAAa,EAAE,EACrE,KAAKkD,IAAQ,UACT,MAAO,CAAE,KAAMlD,kBAAU,QAAS,aAAc,GAAI,YAAa,EAAE,EACvE,KAAKkD,IAAQ,QACT,MAAO,CAAE,KAAMlD,kBAAU,MAAO,aAAc,GAAI,YAAa,EAAE,EACrE,KAAKkD,IAAQ,OACT,MAAO,CAAE,KAAMlD,kBAAU,KAAM,aAAc,GAAI,YAAa,EAAE,EACpE,KAAKkD,IAAQ,WACT,MAAO,CAAE,KAAMlD,kBAAU,SAAU,aAAc,GAAI,YAAa,EAAE,EACxE,KAAKkD,IAAQ,YACT,MAAO,CAAE,KAAMlD,kBAAU,UAAW,aAAc,GAAI,YAAa,EAAE,EACzE,KAAKkD,IAAQ,cACT,MAAO,CAAE,KAAMlD,kBAAU,YAAa,aAAc,GAAI,YAAa,EAAE,EAC3E,KAAKkD,IAAQ,WACT,MAAO,CAAE,KAAMlD,kBAAU,SAAU,aAAc,GAAI,YAAa,EAAE,EACxE,KAAKkD,EAAI,WAAW,MAAM,EACtB,KAAM,CAAA,CAAGF,EAAYY,CAAS,EAAItH,EAAI,MAAM,GAAG,EAC/C,MAAO,CAAE,KAAM0D,QAAAA,UAAU,IAAK,aAAcgD,GAAc,GAAI,YAAaY,GAAa,EAAE,EAC9F,QACI,MAAM,IAAI,MAAM,gCAAgCtH,CAAG,EAAE,CACjE,CACA,CACA,SAASgH,GAAqBH,EAAW,CACrC,MAAM3B,EAAQ,CAAA,EACd,IAAIW,EAAU,GACV0B,EAAQ,KACZ,UAAWC,KAAMX,GACRW,IAAO,KAAOA,IAAO,KAAOA,IAAO,MAAQD,IAAU,MACtDA,EAAQC,EACR3B,GAAW2B,GAEND,GAASC,IAAOD,GACrBA,EAAQ,KACR1B,GAAW2B,GAEN,CAACD,GAASC,IAAO,KAClB3B,EAAQ,QACRX,EAAM,KAAKW,EAAQ,MAAM,EAE7BA,EAAU,IAGVA,GAAW2B,EAGnB,OAAI3B,EAAQ,QACRX,EAAM,KAAKW,EAAQ,MAAM,EAEtBX,CACX,CACA,SAASgC,GAAmBjC,EAAOwC,EAAY,CAC3C,MAAMC,EAAUD,EAAW,KAAI,EAC/B,GAAKC,EAGL,IAAIzC,EAAM,OAASvB,QAAAA,UAAU,IAAK,CAC9BuB,EAAM,eAAiByC,EACvB,MACJ,CACAzC,EAAM,aAAe0C,EAAoB1C,EAAM,KAAMyC,CAAO,EAChE,CACA,SAASP,GAAsBhC,EAAM,CACjC,MAAMyC,EAASzC,EAAK,QAAQ,GAAG,GAAK,EAAIA,EAAK,QAAQ,GAAG,EAAIA,EAAK,QAAQ,GAAG,EAC5E,OAAIyC,IAAW,GACJzC,EAEJA,EAAK,MAAMyC,EAAS,CAAC,CAChC,CACA,SAASD,EAAoB/D,EAAM8D,EAAS,CACxC,OAAQ9D,EAAI,CACR,KAAKF,QAAAA,UAAU,KACX,OAAO,IAAIC,EAAaC,EAAM8D,EAAQ,YAAW,IAAO,QAAUA,IAAY,GAAG,EACrF,KAAKhE,QAAAA,UAAU,MACX,OAAO,IAAIC,EAAaC,EAAM,OAAW,OAAO8D,CAAO,CAAC,EAC5D,KAAKhE,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACX,OAAO,IAAIC,EAAaC,EAAM,OAAW,OAAW,OAAO8D,CAAO,CAAC,EACvE,KAAKhE,QAAAA,UAAU,QACX,OAAO,IAAIC,EAAaC,EAAM,OAAW,OAAW,OAAW,OAAO8D,CAAO,CAAC,EAClF,KAAKhE,QAAAA,UAAU,OACX,OAAO,IAAIC,EAAaC,EAAM,OAAW,OAAW,OAAW,OAAWiE,GAAmBH,CAAO,CAAC,EACzG,KAAKhE,QAAAA,UAAU,MACX,OAAO,IAAIC,EAAaC,EAAM,OAAW,OAAW,OAAW,OAAW,OAAWkE,GAAkBJ,CAAO,CAAC,EACnH,KAAKhE,QAAAA,UAAU,KACX,OAAO,IAAIC,EAAaC,EAAM,OAAW3B,EAAWlC,EAAUgI,EAAYL,CAAO,CAAC,CAAC,CAAC,EACxF,KAAKhE,QAAAA,UAAU,SACX,OAAO,IAAIC,EAAaC,EAAM,OAAW5B,EAAcxB,EAAcuH,EAAYL,CAAO,CAAC,CAAC,CAAC,EAC/F,KAAKhE,QAAAA,UAAU,UACX,OAAO,IAAIC,EAAaC,EAAM,OAAW5B,EAAcZ,EAAe2G,EAAYL,CAAO,CAAC,CAAC,CAAC,EAChG,KAAKhE,QAAAA,UAAU,YAAa,CACxB,MAAMsE,EAAK1G,EAAiByG,EAAYL,CAAO,CAAC,EAChD,OAAO,IAAI/D,EAAaC,EAAM,OAAW,OAAW,OAAW,OAAWzB,EAAkB6F,CAAE,CAAC,CACnG,CACA,KAAKtE,QAAAA,UAAU,SACX,OAAO,IAAIC,EAAaC,EAAM,OAAWrC,EAAcwG,EAAYL,CAAO,CAAC,CAAC,EAChF,QACI,MAAM,IAAI,MAAM,yCAAyC9D,CAAI,EAAE,CAC3E,CACA,CACA,SAASiE,GAAmB7H,EAAK,CAC7B,MAAMC,EAAUD,EAAI,KAAI,EACxB,OAAKC,EAGDA,EAAQ,WAAW,GAAI,GAAKA,EAAQ,WAAW,GAAG,GAAKA,EAAQ,WAAW,GAAG,EACtEA,EAAQ,MAAM,EAAG,EAAE,EAEvBA,EALI,EAMf,CACA,SAAS8H,EAAY/H,EAAK,CACtB,MAAMC,EAAUD,EAAI,KAAI,EACxB,OAAKC,EAGAA,EAAQ,WAAW,GAAI,GAAKA,EAAQ,SAAS,GAAI,GAAOA,EAAQ,WAAW,GAAG,GAAKA,EAAQ,SAAS,GAAG,GAAOA,EAAQ,WAAW,GAAG,GAAKA,EAAQ,SAAS,GAAG,EACvJA,EAAQ,MAAM,EAAG,EAAE,EAEvBA,EALI,EAMf,CACA,SAAS6H,GAAkB9H,EAAK,CAC5B,MAAMC,EAAUD,EAAI,KAAI,EACxB,GAAIC,EAAQ,WAAW,IAAI,GAAKA,EAAQ,WAAW,IAAI,EAAG,CACtD,MAAMgI,EAAMhI,EAAQ,MAAM,CAAC,EAC3B,GAAIgI,EAAI,OAAS,IAAM,EACnB,MAAM,IAAI,MAAM,6BAA6BjI,CAAG,EAAE,EAEtD,MAAM/D,EAAQ,IAAI,WAAWgM,EAAI,OAAS,CAAC,EAC3C,QAAS,EAAI,EAAG,EAAIA,EAAI,OAAQ,GAAK,EACjChM,EAAM,EAAI,CAAC,EAAI,SAASgM,EAAI,MAAM,EAAG,EAAI,CAAC,EAAG,EAAE,EAEnD,OAAOhM,CACX,CACA,OAAO,IAAI,YAAW,EAAG,OAAO8L,EAAY9H,CAAO,CAAC,CACxD,CACA,SAASqG,EAAaV,EAAML,EAAQ,CAChC,MAAMc,EAAM,CAAA,EACN6B,EAAStC,EAAK,MAAM,GAAG,EAC7B,IAAIuC,EAAW,EACXjF,EAAYkF,GAAiBF,CAAM,EACvC,MAAMG,EAAW,IAAM,CACnB,KAAOF,EAAW5C,EAAO,OAAO,QAAUA,EAAO,OAAO4C,CAAQ,EAAE,eAAe,CAC7E,MAAMG,EAAUC,GAAahD,EAAO,OAAQ4C,CAAQ,EACpD,GAAIjF,EAAYoF,EACZ,OAEJH,GAAY,CAChB,CACJ,EACA,UAAW1G,KAASyG,EAAQ,CACxB,MAAMjI,EAAUwB,EAAM,KAAI,EAC1B,GAAI,CAACxB,EAAS,CACVkI,GAAY,EACZ,QACJ,CACA,GAAIlI,EAAQ,WAAW,GAAG,EAAG,CACzB,KAAM,CAAE,MAAAuI,EAAO,MAAA3L,GAAU4L,GAAwBlD,EAAQtF,EAAQ,MAAM,CAAC,CAAC,EACrEuI,GAAS,IACTnC,EAAId,EAAO,OAAOiD,CAAK,EAAE,IAAI,EAAI3L,EACjCsL,EAAW,KAAK,IAAIA,EAAUK,EAAQ,CAAC,GAE3C,QACJ,CAEA,GADAH,EAAQ,EACJF,GAAY5C,EAAO,OAAO,OAC1B,MAAM,IAAI,MAAM,8BAA8B,EAElD,MAAMN,EAAQM,EAAO,OAAO4C,CAAQ,EACpC9B,EAAIpB,EAAM,IAAI,EAAIyD,GAAWzI,EAASgF,CAAK,EAC3CkD,GAAY,EACZjF,GAAa,CACjB,CACA,OAAOmD,CACX,CACA,SAAS+B,GAAiBF,EAAQ,CAC9B,OAAOA,EAAO,OAAO,CAAC3L,EAAKkF,IAAU,CACjC,MAAMxB,EAAUwB,EAAM,KAAI,EAC1B,MAAI,CAACxB,GAAWA,EAAQ,WAAW,GAAG,EAC3B1D,EAEJA,EAAM,CACjB,EAAG,CAAC,CACR,CACA,SAASgM,GAAa1D,EAAQ8D,EAAO,CACjC,IAAIlK,EAAQ,EACZ,QAASvC,EAAIyM,EAAOzM,EAAI2I,EAAO,OAAQ3I,GAAK,EACnC2I,EAAO3I,CAAC,EAAE,gBACXuC,GAAS,GAGjB,OAAOA,CACX,CACA,SAASgK,GAAwBlD,EAAQqD,EAAM,CAC3C,KAAM,CAACC,EAAYC,CAAQ,EAAIF,EAAK,MAAM,IAAK,CAAC,EAChD,GAAI,CAACE,EACD,MAAM,IAAI,MAAM,4BAA4BF,CAAI,EAAE,EAEtD,MAAMG,EAAaC,GAA0BH,CAAU,EACjDxJ,EAAMkG,EAAO,cAAcwD,CAAU,EAC3C,GAAI1J,IAAQ,OACR,MAAM,IAAI,MAAM,eAAe0J,CAAU,YAAY,EAEzD,MAAM9D,EAAQM,EAAO,OAAOlG,CAAG,EAC/B,MAAO,CAAE,MAAOA,EAAK,MAAOqJ,GAAWI,EAAS,OAAQ7D,CAAK,CAAC,CAClE,CACA,SAAS+D,GAA0BvH,EAAO,CAEtC,MAAMwH,EADUxH,EAAM,KAAI,EACJ,MAAM,GAAG,EAC/B,OAAIwH,EAAM,QAAU,EACTA,EAAM,CAAC,EAEXA,EAAM,CAAC,CAClB,CACA,SAASP,GAAW1I,EAAKiF,EAAO,CAC5B,MAAMrB,EAAOqB,EAAM,UAAS,EACtBhF,EAAUD,EAAI,KAAI,EACxB,OAAQ4D,EAAI,CACR,KAAKF,QAAAA,UAAU,OACX,OAAO,OAAOzD,CAAO,EACzB,KAAKyD,QAAAA,UAAU,MACX,OAAO,OAAOzD,CAAO,EACzB,KAAKyD,QAAAA,UAAU,QACX,OAAO,OAAOzD,CAAO,EACzB,KAAKyD,QAAAA,UAAU,KACX,OAAOzD,EAAQ,YAAW,IAAO,QAAUA,IAAY,IAC3D,KAAKyD,QAAAA,UAAU,OACX,OAAOqE,EAAY9H,CAAO,EAC9B,KAAKyD,QAAAA,UAAU,MACX,OAAOoE,GAAkB7H,CAAO,EACpC,KAAKyD,QAAAA,UAAU,KACX,OAAO3D,EAAUgI,EAAY9H,CAAO,CAAC,EACzC,KAAKyD,QAAAA,UAAU,SACX,OAAOlD,EAAcuH,EAAY9H,CAAO,CAAC,EAC7C,KAAKyD,QAAAA,UAAU,UACX,OAAOtC,EAAe2G,EAAY9H,CAAO,CAAC,EAC9C,KAAKyD,QAAAA,UAAU,YACX,OAAOpC,EAAiByG,EAAY9H,CAAO,CAAC,EAChD,KAAKyD,QAAAA,UAAU,SACX,OAAOnC,EAAcwG,EAAY9H,CAAO,CAAC,EAC7C,QACI,OAAOA,CACnB,CACA,CACA,SAASuF,GAAmBgB,EAAKjB,EAAQ,CACrCA,EAAO,OAAO,QAAQ,CAACN,EAAO5F,IAAQ6J,GAAiB1C,EAAKjB,EAAQlG,EAAK,IAAI,GAAK,CAAC,CACvF,CACA,SAAS6J,GAAiB1C,EAAKjB,EAAQlG,EAAK8J,EAAO,CAC/C,MAAMlE,EAAQM,EAAO,OAAOlG,CAAG,EAC/B,GAAI4F,EAAM,eAAiBvB,QAAAA,UAAU,QACjC,OAAOuB,EAAM,aAEjB,GAAIA,EAAM,OAASvB,QAAAA,UAAU,IACzB,OAAAuB,EAAM,aAAeA,EAAM,KACvBA,EAAM,gBAAkB,CAACA,EAAM,eAC/BA,EAAM,aAAe0C,EAAoB1C,EAAM,aAAcA,EAAM,cAAc,EACjFA,EAAM,eAAiB,IAEpBA,EAAM,aAEjB,MAAMmE,EAAM,GAAG7D,EAAO,IAAI,IAAIN,EAAM,IAAI,GACxC,GAAIkE,EAAM,IAAIC,CAAG,EACb,MAAM,IAAI,MAAM,yCAAyCA,CAAG,EAAE,EAElED,EAAM,IAAIC,CAAG,EACb,MAAM7E,EAAeiC,EAAI,QAAQ,IAAIvB,EAAM,YAAY,EACvD,GAAI,CAACV,EACD,MAAM,IAAI,MAAM,gBAAgBgB,EAAO,IAAI,8BAA8BN,EAAM,YAAY,EAAE,EAEjG,MAAMoE,EAAY9E,EAAa,cAAcU,EAAM,WAAW,EAC9D,GAAIoE,IAAc,OACd,MAAM,IAAI,MAAM,gBAAgB9D,EAAO,IAAI,6BAA6BN,EAAM,YAAY,IAAIA,EAAM,WAAW,EAAE,EAErH,MAAMqE,EAAWJ,GAAiB1C,EAAKjC,EAAc8E,EAAWF,CAAK,EACrE,OAAAlE,EAAM,aAAeqE,EACrBH,EAAM,OAAOC,CAAG,EACZnE,EAAM,gBAAkB,CAACA,EAAM,eAC/BA,EAAM,aAAe0C,EAAoB2B,EAAUrE,EAAM,cAAc,EACvEA,EAAM,eAAiB,IAEpBqE,CACX,CACA,SAASnF,GAAclI,EAAO,CAC1B,GAAI,OAAO,OAAW,IAClB,OAAO,OAAO,KAAKA,CAAK,EAAE,SAAS,QAAQ,EAE/C,IAAIsN,EAAS,GACb,QAASrN,EAAI,EAAGA,EAAID,EAAM,OAAQC,GAAK,EACnCqN,GAAU,OAAO,aAAatN,EAAMC,CAAC,CAAC,EAE1C,GAAI,OAAO,MAAS,WAChB,OAAO,KAAKqN,CAAM,EAEtB,MAAM,IAAI,MAAM,uDAAuD,CAC3E,CChmBO,MAAMC,EAAY,CAMrB,YAAYjE,EAAQkE,EAAW,KAAM,CALrC9L,EAAA,eACAA,EAAA,iBACAA,EAAA,gBACAA,EAAA,iBAAYhC,EAAY,GACxBgC,EAAA,YAAO,GAEH,KAAK,OAAS4H,EACd,KAAK,SAAWkE,EAChB,KAAK,QAAUlE,EAAO,OAAO,IAAKN,GAAU,CACxC,MAAMrB,EAAOqB,EAAM,UAAS,EACtByE,EAAS,CAAE,KAAA9F,EAAM,SAAU,CAAA,CAAE,EACnC,OAAQA,EAAI,CACR,KAAKF,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACXgG,EAAO,MAAQ,IAAInL,GACnB,MACJ,KAAKmF,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,YACXgG,EAAO,QAAU,IAAIvK,GACrB,MACJ,KAAKuE,QAAAA,UAAU,KACXgG,EAAO,MAAQ,IAAIxK,GACnB,MACJ,KAAKwE,QAAAA,UAAU,MACf,KAAKA,QAAAA,UAAU,KACf,KAAKA,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACf,KAAKA,QAAAA,UAAU,SACXgG,EAAO,KAAO,IAAI3K,GAClB,MACJ,KAAK2E,QAAAA,UAAU,QACXgG,EAAO,OAAS,IAAI1K,GACpB,MACJ,KAAK0E,QAAAA,UAAU,MACXgG,EAAO,MAAQ,IAAIpK,GACnB,MACJ,QACI,MAAM,IAAI,MAAM,gCAAgCsE,CAAI,EAAE,CAC1E,CACY,OAAO8F,CACX,CAAC,CACL,CACA,WAAWrK,EAAKxC,EAAO,QACnB8M,EAAA,KAAK,QAAQtK,CAAG,EAAE,QAAlB,MAAAsK,EAAyB,OAAO9M,EACpC,CACA,aAAawC,EAAKxC,EAAO,QACrB8M,EAAA,KAAK,QAAQtK,CAAG,EAAE,UAAlB,MAAAsK,EAA2B,OAAO9M,EACtC,CACA,WAAWwC,EAAKxC,EAAO,QACnB8M,EAAA,KAAK,QAAQtK,CAAG,EAAE,QAAlB,MAAAsK,EAAyB,OAAO9M,EACpC,CACA,UAAUwC,EAAKxC,EAAO,QAClB8M,EAAA,KAAK,QAAQtK,CAAG,EAAE,OAAlB,MAAAsK,EAAwB,OAAO9M,EACnC,CACA,YAAYwC,EAAKxC,EAAO,QACpB8M,EAAA,KAAK,QAAQtK,CAAG,EAAE,SAAlB,MAAAsK,EAA0B,OAAO9M,EACrC,CACA,YAAYwC,EAAKxC,EAAO,QACpB8M,EAAA,KAAK,QAAQtK,CAAG,EAAE,QAAlB,MAAAsK,EAAyB,OAAO9M,EACpC,CACA,eAAewC,EAAKuK,EAAS,CACzB,KAAK,QAAQvK,CAAG,EAAE,SAAS,KAAKuK,CAAO,CAC3C,CACA,SAAU,CAEN,GADA,KAAK,MAAQ,EACT,KAAK,KAAO,KAAK,SACjB,MAAM,IAAI,MAAM,sCAAsC,CAE9D,CACA,MAAO,CACH,OAAO,KAAK,MAAQ,KAAK,QAC7B,CACA,UAAW,CACP,OAAO,KAAK,IAChB,CACA,OAAQ,iBACJ,KAAK,KAAO,EACZ,UAAWC,KAAU,KAAK,QACtBA,EAAO,SAAS,OAAS,GACzBF,EAAAE,EAAO,QAAP,MAAAF,EAAc,SACdG,EAAAD,EAAO,UAAP,MAAAC,EAAgB,SAChBC,EAAAF,EAAO,QAAP,MAAAE,EAAc,SACdC,EAAAH,EAAO,OAAP,MAAAG,EAAa,SACbC,EAAAJ,EAAO,SAAP,MAAAI,EAAe,SACfC,EAAAL,EAAO,QAAP,MAAAK,EAAc,OAEtB,CACA,OAAO1L,EAAK,iBACR,GAAI,KAAK,OAAS,EAGlB,CAAA5B,EAAa4B,EAAK,KAAK,IAAI,EAC3B5B,EAAa4B,EAAK,KAAK,QAAQ,MAAM,EACrC,QAASa,EAAM,EAAGA,EAAM,KAAK,QAAQ,OAAQA,GAAO,EAAG,CACnD,MAAMwK,EAAS,KAAK,QAAQxK,CAAG,EAG/B,OAFA,KAAK,UAAU,OAAS,EACxB8K,GAAc,KAAK,UAAWN,EAAO,SAAU,KAAK,IAAI,EAChDA,EAAO,KAAI,CACf,KAAKnG,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,KACXiG,EAAAE,EAAO,QAAP,MAAAF,EAAc,OAAO,KAAK,WAC1B,MACJ,KAAKjG,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,aACXoG,EAAAD,EAAO,UAAP,MAAAC,EAAgB,OAAO,KAAK,WAC5B,MACJ,KAAKpG,QAAAA,UAAU,MACXqG,EAAAF,EAAO,QAAP,MAAAE,EAAc,OAAO,KAAK,WAC1B,MACJ,KAAKrG,QAAAA,UAAU,MACf,KAAKA,QAAAA,UAAU,KACf,KAAKA,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACf,KAAKA,QAAAA,UAAU,UACXsG,EAAAH,EAAO,OAAP,MAAAG,EAAa,OAAO,KAAK,WACzB,MACJ,KAAKtG,QAAAA,UAAU,SACXuG,EAAAJ,EAAO,SAAP,MAAAI,EAAe,OAAO,KAAK,WAC3B,MACJ,KAAKvG,QAAAA,UAAU,OACXwG,EAAAL,EAAO,QAAP,MAAAK,EAAc,OAAO,KAAK,WAC1B,MACJ,QACI,MAAM,IAAI,MAAM,gCAAgCL,EAAO,IAAI,EAAE,CACjF,CACYjN,EAAa4B,EAAKa,CAAG,EACrBvD,EAAS0C,EAAKqL,EAAO,IAAI,EACzBjN,EAAa4B,EAAK,KAAK,UAAU,MAAM,EACvCxC,EAAUwC,EAAK,KAAK,SAAS,CACjC,EACJ,CACJ,CACA,SAAS2L,GAAc3L,EAAK4L,EAAUC,EAAM,CACxC,MAAMC,EAAU,KAAK,OAAOD,EAAO,GAAK,CAAC,EAEzC,GADAzN,EAAa4B,EAAK8L,CAAO,EACrBA,IAAY,EACZ,OAEJ,IAAIzE,EAAU,EACV0E,EAAQ,EACRC,EAAU,EACd,QAASnE,EAAM,EAAGA,EAAMgE,EAAMhE,GAAO,EAC7B+D,EAAS/D,CAAG,IACZR,GAAW,GAAK0E,GAEpBA,GAAS,EACLA,IAAU,IACVzO,EAAS0C,EAAKqH,CAAO,EACrB2E,GAAW,EACX3E,EAAU,EACV0E,EAAQ,GAOhB,IAJIA,IAAU,IACVzO,EAAS0C,EAAKqH,CAAO,EACrB2E,GAAW,GAERA,EAAUF,GACbxO,EAAS0C,EAAK,CAAC,EACfgM,GAAW,CAEnB,CCjKA,MAAMC,EAAQ,OACRC,GAAU,EACVC,GAAc,IAAI,YACjB,MAAMC,CAAI,CAGb,YAAYrF,EAAQ,CAFpB5H,EAAA,eACAA,EAAA,eAEI,KAAK,OAAS4H,EACd,KAAK,OAAS,IAAI,MAAMA,EAAO,OAAO,MAAM,EAAE,KAAK,IAAI,EAAE,IAAI,KAAO,CAAE,IAAK,EAAK,EAAG,CACvF,CACA,OAAQ,CACJ,UAAW1I,KAAS,KAAK,OACrBA,EAAM,IAAM,GACZA,EAAM,KAAO,OACbA,EAAM,IAAM,OACZA,EAAM,MAAQ,OACdA,EAAM,IAAM,OACZA,EAAM,MAAQ,OACdA,EAAM,KAAO,OACbA,EAAM,SAAW,MAEzB,CACA,WAAWwC,EAAKxC,EAAO,CACnB,KAAK,OAAOwC,CAAG,EAAI,CAAE,GAAGxC,EAAO,IAAK,EAAI,CAC5C,CACA,aAAc,CACV,OAAO,KAAK,MAChB,CACA,WAAWwH,EAAM,CACb,OAAO,KAAK,OAAO,iBAAiBA,CAAI,CAC5C,CACA,SAASY,EAAOpI,EAAO,CACnB,KAAK,WAAW,KAAK,WAAWoI,CAAK,EAAGpI,CAAK,CACjD,CACA,QAAQoI,EAAOpI,EAAO,CAClB,MAAMgO,EAAO,KAAK,UAAU,KAAK,WAAW5F,CAAK,CAAC,EAClD4F,EAAK,KAAO,OAAOhO,CAAK,CAC5B,CACA,OAAOoI,EAAOpI,EAAO,CACjB,MAAMgO,EAAO,KAAK,UAAU,KAAK,WAAW5F,CAAK,CAAC,EAClD4F,EAAK,IAAM,OAAOhO,CAAK,CAC3B,CACA,SAASoI,EAAOpI,EAAO,CACnB,MAAMgO,EAAO,KAAK,UAAU,KAAK,WAAW5F,CAAK,CAAC,EAClD4F,EAAK,MAAQhO,CACjB,CACA,QAAQoI,EAAOpI,EAAO,CAClB,MAAMgO,EAAO,KAAK,UAAU,KAAK,WAAW5F,CAAK,CAAC,EAClD4F,EAAK,KAAOhO,CAChB,CACA,UAAUoI,EAAOpI,EAAO,CACpB,MAAMgO,EAAO,KAAK,UAAU,KAAK,WAAW5F,CAAK,CAAC,EAClD4F,EAAK,IAAMhO,CACf,CACA,SAASoI,EAAOpI,EAAO,CACnB,MAAMgO,EAAO,KAAK,UAAU,KAAK,WAAW5F,CAAK,CAAC,EAClD4F,EAAK,MAAQC,EAAWjO,CAAK,CACjC,CACA,UAAUwC,EAAK,CACX,MAAMwL,EAAO,KAAK,OAAOxL,CAAG,EAC5B,OAAAwL,EAAK,IAAM,GACXA,EAAK,KAAO,OACZA,EAAK,IAAM,OACXA,EAAK,MAAQ,OACbA,EAAK,IAAM,OACXA,EAAK,MAAQ,OACbA,EAAK,KAAO,OACZA,EAAK,SAAW,GACTA,CACX,CACJ,CACO,MAAME,EAAO,CAKhB,YAAYxF,EAAQyF,EAAc,KAAM,CAJxCrN,EAAA,eACAA,EAAA,gBACAA,EAAA,cAAShC,EAAY,GACrBgC,EAAA,qBAAgB,IAEZ,KAAK,OAAS4H,EACd,KAAK,QAAU,IAAIiE,GAAYjE,EAAQyF,CAAW,CACtD,CACA,SAAS3E,EAAK,CACV,GAAIA,EAAI,SAAW,KAAK,OACpB,MAAM,IAAI,MAAM,+BAA+B,EAEnD,KAAK,aAAY,EACjB,MAAM7G,EAAS6G,EAAI,YAAW,EAC9B,KAAK,OAAO,OAAO,QAAQ,CAACpB,EAAO5F,IAAQ,CACvC,MAAMxC,EAAQ2C,EAAOH,CAAG,EACxB,GAAI,CAACxC,EAAM,IAAK,CACZ,KAAK,QAAQ,eAAewC,EAAK,EAAK,EACtC,MACJ,CAEA,OADA,KAAK,QAAQ,eAAeA,EAAK,EAAI,EAC7B4F,EAAM,UAAS,EAAE,CACrB,KAAKvB,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACX,KAAK,QAAQ,WAAWrE,EAAKxC,EAAM,MAAQ,EAAE,EAC7C,MACJ,KAAK6G,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,YACX,KAAK,QAAQ,aAAarE,EAAKxC,EAAM,KAAO,EAAE,EAC9C,MACJ,KAAK6G,QAAAA,UAAU,KACX,KAAK,QAAQ,WAAWrE,EAAKxC,EAAM,MAAQ,EAAK,EAChD,MACJ,KAAK6G,QAAAA,UAAU,MACf,KAAKA,QAAAA,UAAU,KACf,KAAKA,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACf,KAAKA,QAAAA,UAAU,SACX,KAAK,QAAQ,UAAUrE,EAAKxC,EAAM,KAAO,EAAE,EAC3C,MACJ,KAAK6G,QAAAA,UAAU,QACX,KAAK,QAAQ,YAAYrE,EAAKxC,EAAM,OAAS,CAAC,EAC9C,MACJ,KAAK6G,QAAAA,UAAU,MACX,KAAK,QAAQ,YAAYrE,EAAKxC,EAAM,OAAS,IAAI,UAAY,EAC7D,MACJ,QACI,MAAM,IAAI,MAAM,gCAAgCoI,EAAM,UAAS,CAAE,EAAE,CACvF,CACQ,CAAC,EACD,KAAK,QAAQ,QAAO,EAChB,KAAK,QAAQ,QACb,KAAK,UAAS,CAEtB,CACA,QAAS,CACL,YAAK,UAAS,EACP9I,EAAmB,KAAK,MAAM,CACzC,CACA,cAAe,CACX,GAAI,KAAK,cACL,OAEJ,UAAWqL,KAAMiD,EACb,KAAK,OAAO,KAAKjD,EAAG,WAAW,CAAC,CAAC,EAErC,KAAK,OAAO,KAAKkD,EAAO,EACxB,MAAMO,EAAK,KAAK,OAAO,YAAW,EAC5BrM,EAAS,IAAI,WAAW,CAAC,EAC/B,IAAIP,EAAO4M,EACX,QAAS,EAAI,EAAG,EAAI,EAAG,GAAK,EACxBrM,EAAO,CAAC,EAAI,OAAOP,EAAO,KAAK,EAC/BA,IAAS,GAEbrC,EAAU,KAAK,OAAQ4C,CAAM,EAC7B,KAAK,cAAgB,EACzB,CACA,WAAY,CACR,GAAI,KAAK,QAAQ,SAAQ,IAAO,EAC5B,OAEJ,MAAMsM,EAAUvP,EAAY,EAC5B,KAAK,QAAQ,OAAOuP,CAAO,EAC3B,MAAMC,EAASxP,EAAY,EAC3BiB,EAAauO,EAAQD,EAAQ,MAAM,EACnClP,EAAU,KAAK,OAAQmP,CAAM,EAC7BnP,EAAU,KAAK,OAAQkP,CAAO,EAC9B,KAAK,QAAQ,MAAK,CACtB,CACJ,CACA,MAAME,EAAY,CAId,YAAYC,EAAY,CAHxB1N,EAAA,YAAO,GACPA,EAAA,cAAS,GACTA,EAAA,gBAEI,KAAK,QAAU,IAAI,MAAM0N,CAAU,EAAE,KAAK,IAAI,EAAE,IAAI,KAAO,CACvD,KAAM3H,QAAAA,UAAU,QAChB,WAAY,CAAA,EACZ,MAAO,CAAA,EACP,YAAa,CAAA,EACb,cAAe,CAAA,EACf,MAAO,CAAA,EACP,KAAM,CAAA,EACN,OAAQ,CAAA,EACR,MAAO,CAAA,CACnB,EAAU,CACN,CACJ,CACO,MAAM4H,EAAO,CAOhB,YAAYnO,EAAMoI,EAAQgG,EAAU,CAAA,EAAI,CANxC5N,EAAA,aACAA,EAAA,eACAA,EAAA,gBACAA,EAAA,cACAA,EAAA,cAAS,GACTA,EAAA,kBAAa,IAET,KAAK,KAAOR,EACZ,KAAK,OAASoI,EACd,KAAK,QAAUgG,EACf,KAAK,MAAQ,IAAIH,GAAY7F,EAAO,OAAO,MAAM,CACrD,CACA,QAAQc,EAAK,CAIT,GAHI,CAAC,KAAK,YAAc,CAAC,KAAK,cAAa,GAGvC,KAAK,MAAM,QAAU,KAAK,MAAM,MAC5B,CAAC,KAAK,WACN,MAAO,GAGf,MAAMmF,EAAS,KAAK,MAAM,OACpBhM,EAAS6G,EAAI,YAAW,EAC9B,QAAS8B,EAAW,EAAGA,EAAW,KAAK,OAAO,OAAO,OAAQA,GAAY,EAAG,CACxE,MAAMlD,EAAQ,KAAK,OAAO,OAAOkD,CAAQ,EACnC0B,EAAS,KAAK,MAAM,QAAQ1B,CAAQ,EACpCsD,EAAYjM,EAAO2I,CAAQ,EAC3BuD,EAAW7B,EAAO,WAAW2B,CAAM,GAAK,GAC9C,GAAIE,EAAW,EAAG,CACdC,GAAmB1G,EAAOwG,CAAS,EACnC,QACJ,CAEA,OADAA,EAAU,IAAM,GACRxG,EAAM,UAAS,EAAE,CACrB,KAAKvB,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACX+H,EAAU,KAAO5B,EAAO,MAAM6B,CAAQ,EACtC,MACJ,KAAKhI,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,YACX+H,EAAU,IAAM5B,EAAO,YAAYA,EAAO,cAAc6B,CAAQ,GAAK,CAAC,GAAK,GAC3E,MACJ,KAAKhI,QAAAA,UAAU,KACX+H,EAAU,KAAO5B,EAAO,MAAM6B,CAAQ,EACtC,MACJ,KAAKhI,QAAAA,UAAU,MACf,KAAKA,QAAAA,UAAU,KACf,KAAKA,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACf,KAAKA,QAAAA,UAAU,SACX+H,EAAU,IAAM5B,EAAO,KAAK6B,CAAQ,EACpC,MACJ,KAAKhI,QAAAA,UAAU,QACX+H,EAAU,MAAQ5B,EAAO,OAAO6B,CAAQ,EACxC,MACJ,KAAKhI,QAAAA,UAAU,MACX+H,EAAU,MAAQ5B,EAAO,MAAM6B,CAAQ,EACvCD,EAAU,SAAW,KAAK,QAAQ,eAAiB,GACnD,MACJ,QACI,MAAM,IAAI,MAAM,gCAAgCxG,EAAM,UAAS,CAAE,EAAE,CACvF,CACQ,CACA,YAAK,MAAM,QAAU,EACd,EACX,CACA,eAAgB,CACZ,GAAI,KAAK,KAAK,OAASwF,EAAM,OAAS,EAAI,EACtC,MAAO,GAGX,GADcE,GAAY,OAAO,KAAK,KAAK,SAAS,EAAGF,EAAM,MAAM,CAAC,IACtDA,EACV,MAAM,IAAI,MAAM,6BAA6B,EAEjD,MAAMmB,EAAU,KAAK,KAAKnB,EAAM,MAAM,EACtC,GAAImB,IAAYlB,GACZ,MAAM,IAAI,MAAM,6BAA6BkB,CAAO,EAAE,EAE1D,MAAMC,EAAU,KAAK,KAAK,SAASpB,EAAM,OAAS,EAAGA,EAAM,OAAS,CAAC,EACrE,IAAIQ,EAAK,GACT,QAAS/O,EAAI,EAAGA,GAAK,EAAGA,GAAK,EACzB+O,EAAMA,GAAM,GAAM,OAAOY,EAAQ3P,CAAC,CAAC,EAEvC,GAAI+O,IAAO,KAAK,OAAO,YAAW,EAC9B,MAAM,IAAI,MAAM,mCAAmC,EAEvD,YAAK,OAASR,EAAM,OAAS,EAC7B,KAAK,WAAa,GACX,EACX,CACA,UAAW,CACP,GAAI,KAAK,QAAU,KAAK,KAAK,OACzB,MAAO,GAEX,KAAM,CAAE,MAAOzM,EAAQ,UAAAR,CAAS,EAAKN,EAAY,KAAK,KAAM,KAAK,MAAM,EACvE,KAAK,QAAUM,EACf,MAAMsO,EAAa,OAAO9N,CAAM,EAChC,GAAI8N,IAAe,GAAK,KAAK,OAASA,EAAa,KAAK,KAAK,OACzD,MAAO,GAEX,MAAM9L,EAAM,KAAK,KAAK,SAAS,KAAK,OAAQ,KAAK,OAAS8L,CAAU,EACpE,YAAK,QAAUA,EACf,KAAK,WAAW9L,CAAG,EACZ,EACX,CACA,WAAWA,EAAK,CACZ,IAAI+L,EAAS,EACb,KAAM,CAAE,MAAO1B,EAAM,UAAW2B,CAAQ,EAAK9O,EAAY8C,EAAK+L,CAAM,EACpEA,GAAUC,EACV,MAAMC,EAAW,OAAO5B,CAAI,EACtB,CAAE,MAAO6B,EAAS,UAAWC,CAAW,EAAKjP,EAAY8C,EAAK+L,CAAM,EAC1EA,GAAUI,EACV,MAAMC,EAAc,OAAOF,CAAO,EAClC,GAAIE,IAAgB,KAAK,OAAO,OAAO,OACnC,MAAM,IAAI,MAAM,6BAA6B,EAEjD,KAAK,MAAM,KAAOH,EAClB,KAAK,MAAM,OAAS,EACpB,QAAS/P,EAAI,EAAGA,EAAIkQ,EAAalQ,GAAK,EAAG,CACrC,KAAM,CAAE,MAAOmQ,EAAa,UAAWC,CAAY,EAAKpP,EAAY8C,EAAK+L,CAAM,EAC/EA,GAAUO,EACV,MAAMnE,EAAW,OAAOkE,CAAW,EAC7BzI,EAAO5D,EAAI+L,CAAM,EACvBA,GAAU,EACV,KAAM,CAAE,MAAOQ,EAAY,UAAWC,EAAc,EAAKtP,EAAY8C,EAAK+L,CAAM,EAChFA,GAAUS,GACV,MAAMC,GAAUzM,EAAI,SAAS+L,EAAQA,EAAS,OAAOQ,CAAU,CAAC,EAChER,GAAU,OAAOQ,CAAU,EAC3B,KAAK,aAAapE,EAAUvE,EAAM6I,GAASR,CAAQ,CACvD,CACJ,CACA,aAAa5M,EAAKuE,EAAM6I,EAASpC,EAAM,CACnC,MAAMR,EAAS,KAAK,MAAM,QAAQxK,CAAG,EACrCwK,EAAO,KAAOjG,EACd,MAAMwG,EAAWsC,GAAeD,EAASpC,CAAI,EAC7CR,EAAO,WAAaO,EAAS,QAC7B,MAAMxM,EAAS6O,EAAQ,SAASrC,EAAS,SAAS,EAClD,OAAQxG,EAAI,CACR,KAAKF,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IAAK,CAChB,MAAMiJ,EAAUC,GAAiBhP,EAAQwM,EAAS,QAAQ,EAC1DP,EAAO,MAAQ8C,EAAQ,OACvB,KACJ,CACA,KAAKjJ,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,YAAa,CACxB,MAAMiJ,EAAUE,GAAmBjP,EAAQwM,EAAS,QAAQ,EAC5DP,EAAO,YAAc8C,EAAQ,MAC7B9C,EAAO,cAAgB8C,EAAQ,QAC/B,KACJ,CACA,KAAKjJ,QAAAA,UAAU,KAAM,CACjB,MAAMiJ,EAAUG,GAAiBlP,EAAQwM,EAAS,QAAQ,EAC1DP,EAAO,MAAQ8C,EAAQ,OACvB,KACJ,CACA,KAAKjJ,QAAAA,UAAU,MACf,KAAKA,QAAAA,UAAU,KACf,KAAKA,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACf,KAAKA,QAAAA,UAAU,SAAU,CACrB,MAAMiJ,EAAUI,GAAgBnP,EAAQwM,EAAS,QAAQ,EACzDP,EAAO,KAAO8C,EAAQ,OACtB,KACJ,CACA,KAAKjJ,QAAAA,UAAU,QAAS,CACpB,MAAMiJ,EAAUK,GAAkBpP,EAAQwM,EAAS,QAAQ,EAC3DP,EAAO,OAAS8C,EAAQ,OACxB,KACJ,CACA,KAAKjJ,QAAAA,UAAU,MAAO,CAClB,MAAMiJ,EAAUM,GAAkBrP,EAAQwM,EAAS,SAAU,KAAK,QAAQ,eAAiB,EAAK,EAChGP,EAAO,MAAQ8C,EAAQ,OACvB,KACJ,CACA,QACI,MAAM,IAAI,MAAM,gCAAgC/I,CAAI,EAAE,CACtE,CACI,CACJ,CACA,SAAS8I,GAAevP,EAAMkN,EAAM,CAChC,KAAM,CAAE,MAAO6C,EAAY,UAAA1P,CAAS,EAAKN,EAAYC,EAAM,CAAC,EACtDmN,EAAU,OAAO4C,CAAU,EACjC,IAAInB,EAASvO,EACb,MAAM2P,EAAU,IAAI,MAAM9C,CAAI,EAAE,KAAK,EAAE,EACvC,IAAI+C,EAAW,EACf,QAAS/G,EAAM,EAAGA,EAAMgE,EAAMhE,GAAO,EAAG,CACpC,MAAMgH,EAAU,KAAK,MAAMhH,EAAM,CAAC,EAC5BiH,EAAMjH,EAAM,EACdgH,EAAU/C,GACOnN,EAAK4O,EAASsB,CAAO,EAAK,GAAKC,IAE5CH,EAAQ9G,CAAG,EAAI+G,EACfA,GAAY,EAGxB,CACA,OAAArB,GAAUzB,EACH,CAAE,QAAA6C,EAAS,SAAAC,EAAU,UAAWrB,CAAM,CACjD,CACA,SAASa,GAAiBzP,EAAMoQ,EAAU,CACtC,IAAIxB,EAAS,EACb,KAAM,CAAE,MAAOnN,EAAQ,UAAApB,CAAS,EAAKN,EAAYC,EAAM4O,CAAM,EAC7DA,GAAUvO,EACV,MAAMkB,EAAOE,EAAS,GAChBH,EAAQ,OAAOG,GAAU,EAAE,EACjC,GAAIH,IAAU8O,EACV,MAAM,IAAI,MAAM,kCAAkC,EAEtD,MAAM/N,EAAS,IAAI,MAAMf,CAAK,EAAE,KAAK,EAAE,EACvC,GAAIA,IAAU,EACV,MAAO,CAAE,OAAAe,CAAM,EAEnB,GAAId,IAAS,GACT,QAASxC,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAAG,CAC/B,MAAMqH,EAASrG,EAAYC,EAAM4O,CAAM,EACvCA,GAAUxI,EAAO,UACjB/D,EAAOtD,CAAC,EAAIqH,EAAO,KACvB,KAEC,CACD,IAAIA,EAASrG,EAAYC,EAAM4O,CAAM,EACrCA,GAAUxI,EAAO,UACjB/D,EAAO,CAAC,EAAI+D,EAAO,MACnB,QAASrH,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAC5BqH,EAASrG,EAAYC,EAAM4O,CAAM,EACjCA,GAAUxI,EAAO,UACjB/D,EAAOtD,CAAC,EAAIsD,EAAOtD,EAAI,CAAC,EAAIqH,EAAO,KAE3C,CACA,MAAO,CAAE,OAAA/D,CAAM,CACnB,CACA,SAASuN,GAAgB5P,EAAMoQ,EAAU,CACrC,IAAIxB,EAAS,EACb,KAAM,CAAE,MAAOnN,EAAQ,UAAApB,CAAS,EAAKN,EAAYC,EAAM4O,CAAM,EAC7DA,GAAUvO,EACV,MAAMkB,EAAOE,EAAS,GAChBH,EAAQ,OAAOG,GAAU,EAAE,EACjC,GAAIH,IAAU8O,EACV,MAAM,IAAI,MAAM,iCAAiC,EAErD,MAAM/N,EAAS,IAAI,MAAMf,CAAK,EAAE,KAAK,EAAE,EACvC,GAAIA,IAAU,EACV,MAAO,CAAE,OAAAe,CAAM,EAEnB,GAAId,IAAS,GACT,QAASxC,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAAG,CAC/B,MAAMqH,EAAShG,EAAWJ,EAAM4O,CAAM,EACtCA,GAAUxI,EAAO,UACjB/D,EAAOtD,CAAC,EAAIqH,EAAO,KACvB,KAEC,CACD,IAAIA,EAAShG,EAAWJ,EAAM4O,CAAM,EACpCA,GAAUxI,EAAO,UACjB/D,EAAO,CAAC,EAAI+D,EAAO,MACnB,QAASrH,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAC5BqH,EAAShG,EAAWJ,EAAM4O,CAAM,EAChCA,GAAUxI,EAAO,UACjB/D,EAAOtD,CAAC,EAAIsD,EAAOtD,EAAI,CAAC,EAAIqH,EAAO,KAE3C,CACA,MAAO,CAAE,OAAA/D,CAAM,CACnB,CACA,SAASwN,GAAkB7P,EAAMoQ,EAAU,CACvC,IAAIxB,EAAS,EACb,KAAM,CAAE,MAAOyB,EAAU,UAAAhQ,CAAS,EAAKN,EAAYC,EAAM4O,CAAM,EAC/DA,GAAUvO,EACV,MAAMiB,EAAQ,OAAO+O,CAAQ,EAC7B,GAAI/O,IAAU8O,EACV,MAAM,IAAI,MAAM,mCAAmC,EAEvD,MAAM/N,EAAS,IAAI,MAAMf,CAAK,EAAE,KAAK,CAAC,EAChCgB,EAAO,IAAI,SAAStC,EAAK,OAAQA,EAAK,WAAYA,EAAK,UAAU,EACvE,QAASjB,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAAG,CAC/B,GAAI6P,EAAS,EAAI5O,EAAK,OAClB,MAAM,IAAI,MAAM,8BAA8B,EAElDqC,EAAOtD,CAAC,EAAIuD,EAAK,WAAWsM,EAAQ,EAAI,EACxCA,GAAU,CACd,CACA,MAAO,CAAE,OAAAvM,CAAM,CACnB,CACA,SAASsN,GAAiB3P,EAAMoQ,EAAU,CACtC,IAAIxB,EAAS,EACb,KAAM,CAAE,MAAOyB,EAAU,UAAAhQ,CAAS,EAAKN,EAAYC,EAAM4O,CAAM,EAC/DA,GAAUvO,EACV,MAAMiB,EAAQ,OAAO+O,CAAQ,EAC7B,GAAI/O,IAAU8O,EACV,MAAM,IAAI,MAAM,kCAAkC,EAEtD,MAAM/N,EAAS,IAAI,MAAMf,CAAK,EAC9B,QAASvC,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAC5BsD,EAAOtD,CAAC,EAAIiB,EAAK4O,EAAS7P,CAAC,IAAM,EAErC,MAAO,CAAE,OAAAsD,CAAM,CACnB,CACA,SAASqN,GAAmB1P,EAAMoQ,EAAU,CACxC,IAAIxB,EAAS,EACb,KAAM,CAAE,MAAO0B,EAAY,UAAAjQ,CAAS,EAAKN,EAAYC,EAAM4O,CAAM,EACjEA,GAAUvO,EACV,MAAMkQ,EAAU,OAAOD,CAAU,EAC3BE,EAAQ,IAAI,MAAMD,CAAO,EAC/B,QAASxR,EAAI,EAAGA,EAAIwR,EAASxR,GAAK,EAAG,CACjC,MAAM0R,EAAa1Q,EAAYC,EAAM4O,CAAM,EAC3CA,GAAU6B,EAAW,UACrB,MAAM5P,EAAS,OAAO4P,EAAW,KAAK,EAChC3P,EAAQd,EAAK,SAAS4O,EAAQA,EAAS/N,CAAM,EACnD2P,EAAMzR,CAAC,EAAIyO,GAAY,OAAO1M,CAAK,EACnC8N,GAAU/N,CACd,CACA,KAAM,CAAE,MAAO6P,EAAa,UAAWC,CAAS,EAAK5Q,EAAYC,EAAM4O,CAAM,EAC7EA,GAAU+B,EACV,MAAMC,EAAW,OAAOF,CAAW,EACnC,GAAIE,IAAaR,EACb,MAAM,IAAI,MAAM,mCAAmC,EAEvD,MAAMJ,EAAU,IAAI,MAAMY,CAAQ,EAClC,QAAS7R,EAAI,EAAGA,EAAI6R,EAAU7R,GAAK,EAAG,CAClC,MAAM8R,EAAU9Q,EAAYC,EAAM4O,CAAM,EACxCA,GAAUiC,EAAQ,UAClBb,EAAQjR,CAAC,EAAI,OAAO8R,EAAQ,KAAK,CACrC,CACA,MAAO,CAAE,MAAAL,EAAO,QAAAR,CAAO,CAC3B,CACA,SAASF,GAAkB9P,EAAMoQ,EAAUU,EAAU,CACjD,IAAIlC,EAAS,EACb,KAAM,CAAE,MAAOyB,EAAU,UAAAhQ,CAAS,EAAKN,EAAYC,EAAM4O,CAAM,EAC/DA,GAAUvO,EACV,MAAMiB,EAAQ,OAAO+O,CAAQ,EAC7B,GAAI/O,IAAU8O,EACV,MAAM,IAAI,MAAM,mCAAmC,EAEvD,MAAM/N,EAAS,IAAI,MAAMf,CAAK,EAC9B,QAASvC,EAAI,EAAGA,EAAIuC,EAAOvC,GAAK,EAAG,CAC/B,MAAM0R,EAAa1Q,EAAYC,EAAM4O,CAAM,EAC3CA,GAAU6B,EAAW,UACrB,MAAM5P,EAAS,OAAO4P,EAAW,KAAK,EAChC3P,EAAQd,EAAK,SAAS4O,EAAQA,EAAS/N,CAAM,EACnDwB,EAAOtD,CAAC,EAAI+R,EAAWhQ,EAAQ6M,EAAW7M,CAAK,EAC/C8N,GAAU/N,CACd,CACA,MAAO,CAAE,OAAAwB,CAAM,CACnB,CACA,SAASsL,EAAWoD,EAAK,CACrB,MAAM3O,EAAO,IAAI,WAAW2O,EAAI,MAAM,EACtC,OAAA3O,EAAK,IAAI2O,CAAG,EACL3O,CACX,CACA,SAASoM,GAAmB1G,EAAO4F,EAAM,CACrCA,EAAK,IAAM,GACX,MAAMsD,EAAMlJ,EAAM,aAClB,GAAKkJ,EAIL,OADAtD,EAAK,IAAM,GACHsD,EAAI,KAAI,CACZ,KAAKzK,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACXmH,EAAK,KAAOsD,EAAI,WAAa,GAC7B,MACJ,KAAKzK,QAAAA,UAAU,MACf,KAAKA,QAAAA,UAAU,KACf,KAAKA,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACf,KAAKA,QAAAA,UAAU,SACXmH,EAAK,IAAMsD,EAAI,UAAY,GAC3B,MACJ,KAAKzK,QAAAA,UAAU,QACXmH,EAAK,MAAQsD,EAAI,YAAc,EAC/B,MACJ,KAAKzK,QAAAA,UAAU,KACXmH,EAAK,KAAOsD,EAAI,WAAa,GAC7B,MACJ,KAAKzK,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,YACXmH,EAAK,IAAMsD,EAAI,aAAe,GAC9B,MACJ,KAAKzK,QAAAA,UAAU,MACXmH,EAAK,MAAQsD,EAAI,WAAarD,EAAWqD,EAAI,UAAU,EAAI,IAAI,WAC/D,MACJ,QACItD,EAAK,IAAM,EACvB,CACA,CCtjBA,MAAMuD,GAAc,IAAI,YAClBzD,GAAc,IAAI,YACjB,SAAS0D,GAAe9I,EAAQD,EAAQiG,EAAU,CAAA,EAAI,CACzD,GAAI,CAAChG,EACD,MAAM,IAAI,MAAM,sCAAsC,EAE1D,MAAM+I,EAAS,IAAIvD,GAAOxF,EAAQgG,EAAQ,aAAe,IAAI,EACvDgD,EAAU,IAAI3D,EAAIrF,CAAM,EAC9B,UAAWiJ,KAAUC,GAAWnJ,CAAM,EAAG,CACrC,GAAIkJ,aAAkB5D,EAAK,CACvB,GAAI4D,EAAO,SAAWjJ,EAClB,MAAM,IAAI,MAAM,0CAA0C,EAE9D+I,EAAO,SAASE,CAAM,EACtB,QACJ,CACA,GAAI,CAACE,GAAcF,CAAM,EACrB,MAAM,IAAI,MAAM,6DAA6D,EAEjFG,GAAYJ,EAAShJ,EAAQiJ,CAAM,EACnCF,EAAO,SAASC,CAAO,CAC3B,CACA,OAAOD,EAAO,OAAM,CACxB,CACO,SAASM,GAAiBtJ,EAAQC,EAAQgG,EAAS,CACtD,MAAMsD,EAAU,CAAA,EAChB,UAAWL,KAAUM,GAAkBxJ,EAAQC,EAAQgG,CAAO,EAC1DsD,EAAQ,KAAKL,CAAM,EAEvB,OAAOK,CACX,CACO,SAAUC,GAAkBxJ,EAAQC,EAAQgG,EAAS,CACxD,GAAI,CAAChG,EACD,MAAM,IAAI,MAAM,wCAAwC,EAE5D,MAAM+D,EAAWyF,GAAwBxD,CAAO,EAC1CyD,EAAS,IAAI1D,GAAO2D,GAAsB3J,CAAM,EAAGC,EAAQ,CAAE,cAAe+D,EAAS,cAAe,EACpGjD,EAAM,IAAIuE,EAAIrF,CAAM,EAC1B,KAAOyJ,EAAO,QAAQ3I,CAAG,GAErB,MADqB6I,GAAe7I,EAAKd,EAAQ+D,CAAQ,EAEzDjD,EAAI,MAAK,CAEjB,CACA,SAASoI,GAAWnJ,EAAQ,CACxB,OAAI6J,GAAW7J,CAAM,EACVA,EAEJ,CAACA,CAAM,CAClB,CACA,SAAS6J,GAAWtS,EAAO,CAIvB,OAHIA,GAAS,MAGT,OAAOA,GAAU,SACV,GAGJ,OADWA,EACM,OAAO,QAAQ,GAAM,UACjD,CACA,SAAS6R,GAAc7R,EAAO,CAC1B,OAAIA,aAAiB,IACV,GAEPA,aAAiB,KACV,GAEPA,GAAS,OAAOA,GAAU,SACtB,QAAM,QAAQA,CAAK,GAGnB,YAAY,OAAOA,CAAK,GAAKA,aAAiB,aAK/C,EACX,CACA,SAAS8R,GAAYtI,EAAKd,EAAQiJ,EAAQ,CACtCnI,EAAI,MAAK,EACT,MAAM+I,EAAWC,GAAeb,CAAM,EACtCjJ,EAAO,OAAO,QAAQ,CAACN,EAAO5F,IAAQ,CAClC,MAAMW,EAAMoP,EAASnK,EAAM,IAAI,EAC/B,GAAyBjF,GAAQ,KAC7B,OAEJ,MAAMsP,EAAUC,GAAiBtK,EAAOjF,CAAG,EACvCsP,GACAjJ,EAAI,WAAWhH,EAAKiQ,CAAO,CAEnC,CAAC,CACL,CACA,SAASD,GAAeb,EAAQ,CAC5B,OAAIA,aAAkB,IACVvJ,GAAUuJ,EAAO,IAAIvJ,CAAK,EAE9BA,GAAUuJ,EAAOvJ,CAAK,CAClC,CACA,SAASsK,GAAiBtK,EAAOjF,EAAK,CAClC,GAAyBA,GAAQ,KAC7B,OAAO,KAEX,MAAM4D,EAAOqB,EAAM,UAAS,EACtB4F,EAAO,CAAE,IAAK,EAAI,EACxB,OAAQjH,EAAI,CACR,KAAKF,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACX,OAAAmH,EAAK,KAAO2E,GAAWxP,EAAKiF,EAAM,IAAI,EAC/B4F,EACX,KAAKnH,QAAAA,UAAU,MACX,OAAAmH,EAAK,IAAM4E,GAAUzP,EAAKiF,EAAM,IAAI,EAC7B4F,EACX,KAAKnH,QAAAA,UAAU,QACX,OAAAmH,EAAK,MAAQ6E,GAAY1P,EAAKiF,EAAM,IAAI,EACjC4F,EACX,KAAKnH,QAAAA,UAAU,KACX,OAAAmH,EAAK,KAAO8E,GAAW3P,EAAKiF,EAAM,IAAI,EAC/B4F,EACX,KAAKnH,QAAAA,UAAU,OACX,OAAAmH,EAAK,IAAM+E,GAAa5P,EAAKiF,EAAM,IAAI,EAChC4F,EACX,KAAKnH,QAAAA,UAAU,MACX,OAAAmH,EAAK,MAAQgF,GAAY7P,EAAKiF,EAAM,IAAI,EACjC4F,EACX,KAAKnH,QAAAA,UAAU,KACX,OAAAmH,EAAK,IAAM5I,EAAW6N,EAAW9P,EAAKiF,EAAM,KAAMvB,kBAAU,IAAI,CAAC,EAC1DmH,EACX,KAAKnH,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UACX,OAAAmH,EAAK,IAAM7I,EAAc8N,EAAW9P,EAAKiF,EAAM,KAAMrB,CAAI,CAAC,EACnDiH,EACX,KAAKnH,QAAAA,UAAU,YACX,OAAAmH,EAAK,IAAMkF,GAAkB/P,EAAKiF,EAAM,IAAI,EACrC4F,EACX,KAAKnH,QAAAA,UAAU,SACX,OAAAmH,EAAK,IAAMmF,GAAehQ,EAAKiF,EAAM,IAAI,EAClC4F,EACX,QACI,MAAM,IAAI,MAAM,gCAAgCjH,CAAI,QAAQqB,EAAM,IAAI,EAAE,CACpF,CACA,CACA,SAASuK,GAAW3S,EAAOsB,EAAO,CAC9B,MAAMoF,EAASkM,GAAU5S,EAAOsB,CAAK,EACrC,GAAIoF,EAAS,GACT,MAAM,IAAI,MAAM,SAASpF,CAAK,qBAAqB,EAEvD,OAAOoF,CACX,CACA,SAASkM,GAAU5S,EAAOsB,EAAO,CAC7B,GAAI,OAAOtB,GAAU,SACjB,OAAOA,EAEX,GAAI,OAAOA,GAAU,SAAU,CAC3B,GAAI,CAAC,OAAO,SAASA,CAAK,GAAK,CAAC,OAAO,UAAUA,CAAK,EAClD,MAAM,IAAI,MAAM,SAASsB,CAAK,2BAA2B,EAE7D,GAAI,KAAK,IAAItB,CAAK,EAAI,OAAO,iBACzB,MAAM,IAAI,MAAM,SAASsB,CAAK,6BAA6B,EAE/D,OAAO,OAAOtB,CAAK,CACvB,CACA,GAAI,OAAOA,GAAU,SAAU,CAC3B,MAAMoD,EAAUpD,EAAM,KAAI,EAC1B,GAAI,CAACoD,EACD,MAAM,IAAI,MAAM,SAAS9B,CAAK,kBAAkB,EAEpD,OAAO,OAAO8B,CAAO,CACzB,CACA,MAAM,IAAI,MAAM,SAAS9B,CAAK,sCAAsC,CACxE,CACA,SAASuR,GAAY7S,EAAOsB,EAAO,CAC/B,GAAI,OAAOtB,GAAU,SAAU,CAC3B,GAAI,CAAC,OAAO,SAASA,CAAK,EACtB,MAAM,IAAI,MAAM,SAASsB,CAAK,iBAAiB,EAEnD,OAAOtB,CACX,CACA,GAAI,OAAOA,GAAU,SACjB,OAAO,OAAOA,CAAK,EAEvB,GAAI,OAAOA,GAAU,SAAU,CAC3B,MAAMsD,EAAS,OAAOtD,EAAM,KAAI,CAAE,EAClC,GAAI,OAAO,MAAMsD,CAAM,EACnB,MAAM,IAAI,MAAM,SAAShC,CAAK,6BAA6B,EAE/D,OAAOgC,CACX,CACA,MAAM,IAAI,MAAM,SAAShC,CAAK,mCAAmC,CACrE,CACA,SAASwR,GAAW9S,EAAOsB,EAAO,CAC9B,GAAI,OAAOtB,GAAU,UACjB,OAAOA,EAEX,GAAI,OAAOA,GAAU,SAAU,CAC3B,GAAI,CAAC,OAAO,SAASA,CAAK,EACtB,MAAM,IAAI,MAAM,SAASsB,CAAK,iBAAiB,EAEnD,OAAOtB,IAAU,CACrB,CACA,GAAI,OAAOA,GAAU,SAAU,CAC3B,MAAMkM,EAAalM,EAAM,KAAI,EAAG,YAAW,EAC3C,GAAIkM,IAAe,QAAUA,IAAe,IACxC,MAAO,GAEX,GAAIA,IAAe,SAAWA,IAAe,IACzC,MAAO,GAEX,MAAM,IAAI,MAAM,SAAS5K,CAAK,+BAA+B,CACjE,CACA,MAAM,IAAI,MAAM,SAASA,CAAK,qCAAqC,CACvE,CACA,SAASyR,GAAa/S,EAAOsB,EAAO,CAChC,GAAI,OAAOtB,GAAU,SACjB,OAAOA,EAEX,GAAI,OAAOA,GAAU,UAAY,OAAOA,GAAU,WAAa,OAAOA,GAAU,SAC5E,OAAO,OAAOA,CAAK,EAEvB,GAAIA,aAAiB,KAAM,CACvB,GAAI,CAAC,OAAO,SAASA,EAAM,QAAO,CAAE,EAChC,MAAM,IAAI,MAAM,SAASsB,CAAK,wBAAwB,EAE1D,OAAOtB,EAAM,YAAW,CAC5B,CACA,GAAIA,aAAiB,WACjB,OAAO8N,GAAY,OAAO9N,CAAK,EAEnC,MAAM,IAAI,MAAM,SAASsB,CAAK,oCAAoC,CACtE,CACA,SAAS0R,GAAYhT,EAAOsB,EAAO,CAC/B,GAAItB,aAAiB,WACjB,OAAOA,EAAM,MAAK,EAEtB,GAAI,YAAY,OAAOA,CAAK,EAAG,CAC3B,MAAM4C,EAAO5C,EACb,OAAO,IAAI,WAAW4C,EAAK,OAAO,MAAMA,EAAK,WAAYA,EAAK,WAAaA,EAAK,UAAU,CAAC,CAC/F,CACA,GAAI5C,aAAiB,YACjB,OAAO,IAAI,WAAWA,EAAM,MAAM,CAAC,CAAC,EAExC,GAAI,MAAM,QAAQA,CAAK,EAAG,CACtB,MAAMJ,EAAM,IAAI,WAAWI,EAAM,MAAM,EACvC,OAAAA,EAAM,QAAQ,CAACuC,EAAOC,IAAQ,CAC1B,GAAI,OAAOD,GAAU,UAAY,CAAC,OAAO,SAASA,CAAK,EACnD,MAAM,IAAI,MAAM,SAASjB,CAAK,4CAA4CkB,CAAG,EAAE,EAEnF5C,EAAI4C,CAAG,EAAID,EAAQ,GACvB,CAAC,EACM3C,CACX,CACA,GAAI,OAAOI,GAAU,SACjB,OAAOuR,GAAY,OAAOvR,CAAK,EAEnC,MAAM,IAAI,MAAM,SAASsB,CAAK,kDAAkD,CACpF,CACA,SAAS2R,EAAWjT,EAAOsB,EAAOyF,EAAM,CACpC,GAAI/G,aAAiB,KAAM,CACvB,GAAI,CAAC,OAAO,SAASA,EAAM,QAAO,CAAE,EAChC,MAAM,IAAI,MAAM,SAASsB,CAAK,wBAAwB,EAE1D,OAAOtB,CACX,CACA,GAAI,OAAOA,GAAU,SAAU,CAC3B,MAAMoD,EAAUpD,EAAM,KAAI,EAC1B,GAAI,CAACoD,EACD,MAAM,IAAI,MAAM,SAAS9B,CAAK,sCAAsC,EAExE,OAAQyF,EAAI,CACR,KAAKF,QAAAA,UAAU,KACX,OAAO3D,EAAUE,CAAO,EAC5B,KAAKyD,QAAAA,UAAU,SACX,OAAOlD,EAAcP,CAAO,EAChC,KAAKyD,QAAAA,UAAU,UACX,OAAOtC,EAAenB,CAAO,EACjC,QACI,OAAOmB,EAAenB,CAAO,CAC7C,CACI,CACA,GAAI,OAAOpD,GAAU,SAAU,CAC3B,GAAI,CAAC,OAAO,SAASA,CAAK,EACtB,MAAM,IAAI,MAAM,SAASsB,CAAK,iBAAiB,EAEnD,OAAO8R,GAAepT,CAAK,CAC/B,CACA,GAAI,OAAOA,GAAU,SACjB,OAAOqT,GAAerT,CAAK,EAE/B,MAAM,IAAI,MAAM,SAASsB,CAAK,0CAA0C,CAC5E,CACA,SAAS4R,GAAkBlT,EAAOsB,EAAO,CACrC,GAAItB,aAAiB,KAAM,CACvB,GAAI,CAAC,OAAO,SAASA,EAAM,QAAO,CAAE,EAChC,MAAM,IAAI,MAAM,SAASsB,CAAK,wBAAwB,EAE1D,OAAOgE,EAAkBtF,CAAK,CAClC,CACA,GAAI,OAAOA,GAAU,SACjB,OAAOuF,GAAqBvF,CAAK,EAErC,GAAI,OAAOA,GAAU,SAAU,CAC3B,GAAI,CAAC,OAAO,SAASA,CAAK,EACtB,MAAM,IAAI,MAAM,SAASsB,CAAK,iBAAiB,EAEnD,OAAOgE,EAAkB8N,GAAepT,CAAK,CAAC,CAClD,CACA,GAAI,OAAOA,GAAU,SACjB,OAAOsF,EAAkB+N,GAAerT,CAAK,CAAC,EAElD,MAAM,IAAI,MAAM,SAASsB,CAAK,0CAA0C,CAC5E,CACA,SAAS6R,GAAenT,EAAOsB,EAAO,CAClC,GAAI,OAAOtB,GAAU,SACjB,OAAOA,EAEX,GAAI,OAAOA,GAAU,SAAU,CAC3B,GAAI,CAAC,OAAO,SAASA,CAAK,GAAK,CAAC,OAAO,UAAUA,CAAK,EAClD,MAAM,IAAI,MAAM,SAASsB,CAAK,oCAAoC,EAEtE,GAAI,KAAK,IAAItB,CAAK,EAAI,OAAO,iBACzB,MAAM,IAAI,MAAM,SAASsB,CAAK,sCAAsC,EAExE,OAAO,OAAOtB,CAAK,CACvB,CACA,GAAI,OAAOA,GAAU,SACjB,OAAO0E,EAAc1E,CAAK,EAE9B,MAAM,IAAI,MAAM,SAASsB,CAAK,8CAA8C,CAChF,CACA,SAAS8R,GAAepT,EAAO,CAC3B,GAAI,OAAO,UAAUA,CAAK,EACtB,OAAOwF,EAAcQ,EAAsB,OAAOhG,CAAK,CAAC,CAAC,EAE7D,MAAMgF,EAAQ,KAAK,MAAMhF,CAAK,EACxBsT,EAAatT,EAAQgF,EACrBZ,EAAQ,OAAOY,CAAK,EAAI,YAAc,OAAO,KAAK,MAAMsO,EAAa,GAAa,CAAC,EACzF,OAAO9N,EAAcpB,CAAK,CAC9B,CACA,SAASiP,GAAerT,EAAO,CAC3B,OAAOwF,EAAcQ,EAAsBhG,CAAK,CAAC,CACrD,CACA,SAASoS,GAAsB3J,EAAQ,CACnC,GAAIA,aAAkB,WAClB,OAAOA,EAEX,GAAI,YAAY,OAAOA,CAAM,EAAG,CAC5B,MAAM7F,EAAO6F,EACb,OAAO,IAAI,WAAW7F,EAAK,OAAQA,EAAK,WAAYA,EAAK,UAAU,CACvE,CACA,GAAI6F,aAAkB,YAClB,OAAO,IAAI,WAAWA,CAAM,EAEhC,MAAM,IAAI,MAAM,iCAAiC,CACrD,CACA,SAASyJ,GAAwBxD,EAAS,CACtC,MAAO,CACH,eAAeA,GAAA,YAAAA,EAAS,gBAAiB,GACzC,aAAaA,GAAA,YAAAA,EAAS,cAAe,OACrC,cAAcA,GAAA,YAAAA,EAAS,eAAgB,OACvC,cAAcA,GAAA,YAAAA,EAAS,eAAgB,SACvC,eAAeA,GAAA,YAAAA,EAAS,iBAAkB,KAAO,CAAA,GACzD,CACA,CACA,SAAS2D,GAAe7I,EAAKd,EAAQgG,EAAS,CAC1C,MAAM6E,EAAS7E,EAAQ,cAAa,EAC9B/L,EAAS6G,EAAI,YAAW,EAC9B,OAAAd,EAAO,OAAO,QAAQ,CAACN,EAAO5F,IAAQ,CAClC,MAAMwL,EAAOrL,EAAOH,CAAG,EACvB,GAAI,CAACwL,EAAK,IACN,OAEJ,MAAM8B,EAAU0D,GAAiBpL,EAAO4F,EAAMU,CAAO,EACrD+E,GAAeF,EAAQnL,EAAM,KAAM0H,CAAO,CAC9C,CAAC,EACMyD,CACX,CACA,SAASE,GAAeF,EAAQhH,EAAKvM,EAAO,CACxC,GAAIuT,aAAkB,IAAK,CACvBA,EAAO,IAAIhH,EAAKvM,CAAK,EACrB,MACJ,CACAuT,EAAOhH,CAAG,EAAIvM,CAClB,CACA,SAASwT,GAAiBpL,EAAO4F,EAAMU,EAAS,CAC5C,MAAM3H,EAAOqB,EAAM,UAAS,EAC5B,OAAQrB,EAAI,CACR,KAAKF,QAAAA,UAAU,OACf,KAAKA,QAAAA,UAAU,IACX,OAAO6M,EAAc1F,EAAK,MAAQ,GAAIU,EAAQ,YAAatG,EAAM,KAAM,EAAI,EAC/E,KAAKvB,QAAAA,UAAU,MACX,OAAO6M,EAAc1F,EAAK,KAAO,GAAIU,EAAQ,YAAatG,EAAM,KAAM,EAAK,EAC/E,KAAKvB,QAAAA,UAAU,QACX,OAAOmH,EAAK,OAAS,EACzB,KAAKnH,QAAAA,UAAU,KACX,OAAOmH,EAAK,MAAQ,GACxB,KAAKnH,QAAAA,UAAU,OACX,OAAOmH,EAAK,KAAO,GACvB,KAAKnH,QAAAA,UAAU,MACX,OAAOmH,EAAK,OAAS,IAAI,WAC7B,KAAKnH,QAAAA,UAAU,KAAM,CACjB,MAAMiJ,EAAUnK,GAAWqI,EAAK,KAAO,EAAE,EACzC,OAAOU,EAAQ,eAAiB,SAAW9I,GAAWkK,CAAO,EAAIA,CACrE,CACA,KAAKjJ,QAAAA,UAAU,SACf,KAAKA,QAAAA,UAAU,UAAW,CACtB,MAAMiJ,EAAUtK,EAAcwI,EAAK,KAAO,EAAE,EAC5C,OAAOU,EAAQ,eAAiB,SAAW7I,GAAciK,CAAO,EAAIA,CACxE,CACA,KAAKjJ,QAAAA,UAAU,YAAa,CACxB,MAAMsB,EAAM6F,EAAK,KAAO,GACxB,OAAK7F,EAGDuG,EAAQ,eAAiB,SAClBvG,EAEJ1D,EAAiB0D,CAAG,EALhBuG,EAAQ,eAAiB,OAAS,IAAI,KAAK,CAAC,EAAI,EAM/D,CACA,KAAK7H,QAAAA,UAAU,SACX,OAAO8M,GAAgB3F,EAAK,KAAO,GAAIU,EAAQ,aAActG,EAAM,IAAI,EAC3E,QACI,MAAM,IAAI,MAAM,gCAAgCrB,CAAI,EAAE,CAClE,CACA,CACA,SAAS2M,EAAc1T,EAAO6B,EAAMP,EAAOsS,EAAU,CACjD,GAAIA,GAAY5T,EAAQ,GACpB,MAAM,IAAI,MAAM,SAASsB,CAAK,kCAAkC,EAEpE,OAAQO,EAAI,CACR,IAAK,SACD,OAAO7B,EACX,IAAK,SACD,GAAI,CAAC6T,EAAgB7T,CAAK,EACtB,MAAM,IAAI,MAAM,SAASsB,CAAK,gCAAgC,EAElE,OAAO,OAAOtB,CAAK,EACvB,QACI,OAAO6T,EAAgB7T,CAAK,EAAI,OAAOA,CAAK,EAAIA,CAC5D,CACA,CACA,SAAS2T,GAAgB3T,EAAO6B,EAAMP,EAAO,CACzC,OAAQO,EAAI,CACR,IAAK,SACD,OAAO7B,EACX,IAAK,SACD,GAAI,CAAC6T,EAAgB7T,CAAK,EACtB,MAAM,IAAI,MAAM,kBAAkBsB,CAAK,gCAAgC,EAE3E,OAAO,OAAOtB,CAAK,EACvB,IAAK,SACD,OAAOmG,GAAenG,CAAK,EAC/B,QACI,OAAOA,CACnB,CACA,CACA,SAAS6T,EAAgB7T,EAAO,CAC5B,OAAOA,GAAS,OAAO,OAAO,gBAAgB,GAAKA,GAAS,OAAO,OAAO,gBAAgB,CAC9F,CC3cA,MAAM8N,GAAc,IAAI,YAClBF,EAAQ,OACRC,GAAU,EACT,SAASiG,GAAa/S,EAAQ,CACjC,MAAM6B,EAAO,IAAI,SAAS7B,CAAM,EAChC,IAAIlB,EAAS,EACb,QAASR,EAAI,EAAGA,EAAIuO,EAAM,OAAQvO,GAAK,EAAG,CACtC,GAAIuD,EAAK,SAAS/C,CAAM,IAAM+N,EAAM,WAAWvO,CAAC,EAC5C,MAAM,IAAI,MAAM,4BAA4B,EAEhDQ,GAAU,CACd,CACA,MAAMkP,EAAUnM,EAAK,SAAS/C,CAAM,EAEpC,GADAA,GAAU,EACNkP,IAAYlB,GACZ,MAAM,IAAI,MAAM,oCAAoCkB,CAAO,EAAE,EAEjE,MAAMgF,EAAiBnR,EAAK,aAAa/C,EAAQ,EAAI,EACrDA,GAAU,EACV,MAAMmU,EAAoBpR,EAAK,aAAa/C,EAAQ,EAAI,EACxDA,GAAU,EACV,MAAMoU,EAAY,IAAI,KAAK,OAAOrR,EAAK,YAAY/C,EAAQ,EAAI,EAAI,QAAQ,CAAC,EAC5EA,GAAU,EACV,MAAMqU,EAAYC,EAAgBvR,EAAM7B,EAAQlB,CAAM,EACtDA,GAAUqU,EAAU,MACpB,MAAME,EAAeD,EAAgBvR,EAAM7B,EAAQlB,CAAM,EACzDA,GAAUuU,EAAa,MACvB,MAAMC,EAAaC,EAAS1R,EAAM7B,EAAQlB,CAAM,EAChDA,GAAUwU,EAAW,MACrB,MAAMzE,EAAU0E,EAAS1R,EAAM7B,EAAQlB,CAAM,EAC7C,MAAO,CACH,aAAcqU,EAAU,MACxB,WAAYE,EAAa,MACzB,oBAAqBL,EACrB,kBAAAC,EACA,UAAAC,EACA,WAAYnG,GAAY,OAAOuG,EAAW,IAAI,EAC9C,QAASzE,EAAQ,IACzB,CACA,CACA,SAASuE,EAAgBvR,EAAM7B,EAAQlB,EAAQ,CAC3C,MAAMsB,EAASyB,EAAK,UAAU/C,EAAQ,EAAI,EACpCiM,EAAQjM,EAAS,EACjB0U,EAAMzI,EAAQ3K,EACpB,GAAIoT,EAAMxT,EAAO,WACb,MAAM,IAAI,MAAM,oCAAoC,EAExD,MAAO,CAAE,MAAO+M,GAAY,OAAO/M,EAAO,MAAM+K,EAAOyI,CAAG,CAAC,EAAG,MAAO,EAAIpT,CAAM,CACnF,CACA,SAASmT,EAAS1R,EAAM7B,EAAQlB,EAAQ,CACpC,MAAMsB,EAASyB,EAAK,UAAU/C,EAAQ,EAAI,EACpCiM,EAAQjM,EAAS,EACjB0U,EAAMzI,EAAQ3K,EACpB,GAAIoT,EAAMxT,EAAO,WACb,MAAM,IAAI,MAAM,kCAAkC,EAEtD,MAAO,CAAE,KAAM,IAAI,WAAWA,EAAO,MAAM+K,EAAOyI,CAAG,CAAC,EAAG,MAAO,EAAIpT,CAAM,CAC9E,CCxDA,SAASqT,EAAcC,EAAK,CACxB,MAAMrR,EAAUqR,EAAI,KAAI,EACxB,OAAKrR,EAGEA,EAAQ,SAAS,GAAG,EAAIA,EAAQ,MAAM,EAAG,EAAE,EAAIA,EAF3C,uBAGf,CACA,eAAesR,EAASC,EAAM,CAC1B,GAAIA,EAAK,GACL,OAAOA,EAEX,MAAM9L,EAAO,MAAM8L,EAAK,KAAI,EAC5B,MAAM,IAAI,MAAM9L,GAAQ8L,EAAK,UAAU,CAC3C,CACO,MAAMC,EAAe,CAExB,YAAYC,EAAU,wBAAyB,CAD/C/T,EAAA,gBAEI,KAAK,QAAU0T,EAAcK,CAAO,CACxC,CACA,WAAWJ,EAAK,CACZ,KAAK,QAAUD,EAAcC,CAAG,CACpC,CACA,IAAIK,EAAM,CACN,MAAO,GAAG,KAAK,OAAO,GAAGA,CAAI,EACjC,CACA,MAAM,eAAgB,CAKlB,OADa,MAHA,MAAMJ,EAAS,MAAM,MAAM,KAAK,IAAI,YAAY,EAAG,CAC5D,QAAS,CAAE,OAAQ,YAAY,CAC3C,CAAS,CAAC,GACsB,KAAI,GAEvB,MAAM,OAAO,EACb,IAAK3L,GAASA,EAAK,KAAI,CAAE,EACzB,OAAO,OAAO,CACvB,CACA,MAAM,iBAAiBvB,EAAM,CAIzB,OAHa,MAAMkN,EAAS,MAAM,MAAM,KAAK,IAAI,cAAc,mBAAmBlN,CAAI,CAAC,EAAE,EAAG,CACxF,QAAS,CAAE,OAAQ,YAAY,CAC3C,CAAS,CAAC,GACU,KAAI,CACpB,CACA,MAAM,aAAaA,EAAMsC,EAAM,CAC3B,MAAM4K,EAAS,MAAM,MAAM,KAAK,IAAI,cAAc,mBAAmBlN,CAAI,CAAC,EAAE,EAAG,CAC3E,OAAQ,OACR,QAAS,CAAE,eAAgB,2BAA2B,EACtD,KAAAsC,CACZ,CAAS,CAAC,CACN,CACA,MAAM,eAAetC,EAAM,CACvB,MAAMkN,EAAS,MAAM,MAAM,KAAK,IAAI,cAAc,mBAAmBlN,CAAI,CAAC,EAAE,EAAG,CAC3E,OAAQ,QACpB,CAAS,CAAC,CACN,CACA,MAAM,cAAcmC,EAAKjB,EAAQkH,EAAS,CACtC,MAAM8E,EAAS,MAAM,MAAM,KAAK,IAAI,YAAY,mBAAmB/K,CAAG,CAAC,IAAI,mBAAmBjB,CAAM,CAAC,EAAE,EAAG,CACtG,OAAQ,OACR,QAAS,CAAE,eAAgB,oBAAoB,EAC/C,KAAMkH,CAClB,CAAS,CAAC,CACN,CACA,MAAM,aAAajG,EAAKjB,EAAQ,CAE5B,MAAM3H,EAAS,MADF,MAAM2T,EAAS,MAAM,MAAM,KAAK,IAAI,YAAY,mBAAmB/K,CAAG,CAAC,IAAI,mBAAmBjB,CAAM,CAAC,EAAE,CAAC,CAAC,GAC5F,YAAW,EACrC,OAAO,IAAI,WAAW3H,CAAM,CAChC,CACA,MAAM,YAAY4I,EAAKjB,EAAQ,CAE3B,MAAM3H,EAAS,MADF,MAAM2T,EAAS,MAAM,MAAM,KAAK,IAAI,oBAAoB,mBAAmB/K,CAAG,CAAC,WAAW,mBAAmBjB,CAAM,CAAC,EAAE,CAAC,CAAC,GAC3G,YAAW,EACrC,OAAOoL,GAAa/S,CAAM,CAC9B,CACJ"}